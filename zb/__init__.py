#===============================================================
#  Copyright (C)2012-2016 Blender Sensei (Seth Fentress: Licensor)
#  For more information visit Blendersensei.com
#
#  ####BEGIN LICENSE BLOCK #####
#  By using this software (from this point on referred to as "The
#  Software", you (the Licensee) agree to the terms of its license. 
#  The conditions of this license are as follows:
#
#  • You may not redistribute, share or sell this software.
#  • The content you create with this software may be used
#    for personal or commercial use. 
#  • The Software is provided under an AS-IS basis. Licensor shall 
#    never, and without any limit, be liable for any damage, cost, 
#    expense or any other payment incurred by Licensee as a result 
#    of Software’s actions, failure, bugs and/or any other interaction 
#    between The Software and Licensee’s end-equipment, computers, 
#    other software or any 3rd party, end-equipment or services.
#  ####END LICENSE BLOCK #####
#
#===============================================================


bl_info = {
 "name": "Zero Brush",
 "author": "Blender Sensei (Seth Fentress) Blendersensei.com",
 "version": (1, 8, 3),
 "location": "Properties shelf & Tool shelf of Sensei tab (SPACE: brush menu | Q: options)",
 "description": "Zero button texture painting by Blender Sensei",
 "wiki_url": "https://blendersensei.com/zero-brush",
 "category": "Sensei Format"}

i_0 = [
    "ject.zb_particle_detail_select", 
    "Particle Detail Select", 
    "Select the type of particle children detail to increase or decrease (particle edit mode, object mode, render)", 
    "Material Options", 
    "menu.zb_material_options_menu", 
    "Material operations like removing materials or uv maps from a selection.", 
    "Assign Material", 
    "menu.zb_add_material", 
    "Add a material to the selected object, objects or mesh.", 
    "Select By Material", 
    "menu.zb_select_by_material", 
    "Select all objects that are using the material from the list.", 
    "object.zb_material_operations", 
    "Material Operations", 
    "Remove all materials from the selected objects.", 
    "object.sf_apply_tex", 
    "SFK Apply Texture", 
    "Convert images dropped onto objects from the file browser into materials.", 
    "texture.zb_load_brush", 
    "Brush", 
    "Load an image (png, jpeg, tiff, etc..) as a brush", 
    "texture.zb_load_brushes", 
    "Brushes", 
    "Load a folder of images (png, jpeg, tiff, etc..) as brushes", 
    "", 
    "menu.zb_brush_menu", 
    "ZB Brush Context", 
    "object.zb_brush_context", 
    "object.sf_convert", 
    "Convert To Mesh", 
    "Convert non mesh objects into mesh", 
    "object.zb_precise_paint", 
    "ZB Rotate View", 
    "Orthographically rotate view with W,S,A,D and arrow keys", 
    "object.zb_precise_paint_ctrl", 
    "ZB Precise Paint Control", 
    "object.zb_mode_buttons", 
    "ZB Select Mode", 
    "Select Mode: Object | Sculpt | Paint | Particle | Options | Fullscreen", 
    "object.zb_alchemy_paint", 
    "ZB Alchemy Paint", 
    "object.zb_set_active_layer", 
    "Set Active Texture Layer", 
    "Active texture layer", 
    "paint.zb_erase_paint", 
    "ZB Eraser Pen", 
    "Hold shift to erase paint, weight, vertex and mask maps", 
    "object.zb_move_texture", 
    "Move Texture", 
    "Move texture layer up or down", 
    "object.zb_delete_texture", 
    "Delete Texture", 
    "Delete texture layer", 
    "object.zb_reload_all_images", 
    "ZB Reload All Images", 
    "Reload all externally edited images back into Blender", 
    "object.zb_save_layers", 
    "Save My Layers", 
    "Click this before saving your file to save changes made to new layers.", 
    "object.zb_layer_from_brush", 
    "Layer From Brush", 
    "Create a base layer from your texture brush image.", 
    "object.zb_bump_to_normal", 
    "ZB Merge Normals", 
    "Merge visible bump and normal layers into a single normal layer (may take several minutes).", 
    "ZB Bake", 
    "object.zb_bake", 
    "Bake an object or selection of objects (may take several minutes).", 
    "ZB Select Bake Option", 
    "menu.zb_bake_type_select", 
    "object.zb_message_proxy", 
    "", 
    "Click to display more info about this option.", 
    "object.zb_message", 
    "", 
    "Click to display more info about this option.", 
    "ZB System", 
    "menu.zb_system_options", 
    "", 
    "view3D.zb_layer_options_menu", 
    "object.zb_make_unique", 
    "ZB Make Unique", 
    "Make material, textures & images unique (for painting on duplicated objects)", 
    "object.zb_reset_uvs", 
    "Reset UV Map", 
    "Reset object uv map and clear layer", 
    "object.zb_render_prev", 
    "ZB Render Preview", 
    "Render Preview", 
    "object.zb_paint_color", 
    "Add Color", 
    "This adds a regular texture layer you can paint on", 
    "object.zb_paint_bump", 
    "Add Bump", 
    "This adds a layer with a \"bump\" (fake 3D effect) you can paint on", 
    "object.zb_paint_specular", 
    "Add Specular", 
    "This adds a specular or \"Shininess\" map which lets you paint where you want the shine", 
    "object.zb_paint_transparent", 
    "Add Transparent", 
    "This will turn your object invisible and let you paint on it", 
    "object.zb_alpha_mask", 
    "Add Alpha Mask", 
    "This lets you paint transparency onto your object wherever you choose", 
    "object.zb_paint_glow", 
    "Add Glow", 
    "Adds a light emitting layer. Use the force wisely.", 
    "object.zb_paint_normal", 
    "Add Normal", 
    "Convert the detail from your multires modifier into a normal map", 
    "object.zb_multires_add", 
    "Make Sculptable", 
    "Convert selected object into a sculptable object and start sculpting", 
    "object.zb_sculpt_dynamic", 
    "Sculpt Dynamically", 
    "Dynamically generate mesh as you sculpt (requires retopology when finished)", 
    "object.zb_sub_multires", 
    "More Detail", 
    "Subdivide your object for more detailed sculpting", 
    "object.zb_multires_down", 
    "Less Detail", 
    "Reduce your object's sculpt detail", 
    "object.zb_reset_detail", 
    "Reset Detail", 
    "Reset Mesh Detail", 
    "object.zb_generate_base_mesh", 
    "Make Base", 
    "Apply sculpted detail to the underlying mesh permanently", 
    "object.zb_bake_normal", 
    "Bake Multires Normal", 
    "Apply multires sculpt detail as a normal map to your object (may take several minutes).", 
    "object.zb_add_strands", 
    "Add Strands", 
    "Add, copy, or delete particle strands from your object.", 
    "sculpt.zb_stroke_smooth", 
    "ZB Stroke Smooth", 
    "sculpt.zb_stroke_inverse", 
    "ZB Stroke Inverse", 
    "object.zb_stroke_buttons", 
    "Button", 
    "Paint with different shapes: REGULAR BRUSH/ CURVE/ LINE/ CIRCLE", 
    "object.zb_center_stencil", 
    "Center Stencil", 
    "Center stencil and reset rotation and scale", 
    "object.zb_stencil_sync", 
    "Sync Stencils", 
    "IMAGE_EDITOR", 
    "TOOLS", 
    "object.zb_image_edit", 
    "ZB Image Edit Contextualization", 
    "Go back and forth between the 3D View and the image editor", 
    "Zero Brush", 
    "TOOLS", 
    "Sensei", 
    "IMAGE_EDITOR", 
    "TOOLS", 
    "Sensei", 
    "ZB Back To 3D View", 
    "object.zb_back_to_3d_view", 
    "Go back to the 3D View", 
    "Zero Brush", 
    "TOOLS", 
    "Sensei", 
    "VIEW_3D", 
    "TOOLS", 
    "Sensei", 
    "Zero Brush", 
    "TOOLS", 
    "Zero Brush", 
    "VIEW_3D", 
    "UI", 
    "object.sf_tn", 
    "Blank", 
    "Unavailable", 
    "screen.sf_zb_init_listener", 
    "ZB Init Listener", 
    "paint.zb_select_weight_mirror", 
    "ZB Select Weight Mirror", 
    ""
]

import bpy, os, addon_utils
from bpy.props import*
from bpy_extras.io_utils import ImportHelper
from bpy.types import Menu, Panel
from bl_ui.properties_paint_common import (
        UnifiedPaintPanel,
        brush_texture_settings,
        )
default, state = addon_utils.check("Zero_Brush_Lite")
if state:
    try: 
        addon_utils.disable("Sensei_Keys", default_set = True)
        addon_utils.disable("Zero_Brush_Lite", default_set = True)
        addon_utils.enable("Zero_Brush", default_set = True)
        addon_utils.enable("Sensei_Keys", default_set = True)
    except:
        pass
    try:
        bpy.ops.wm.save_userpref('INVOKE_DEFAULT')
    except:
        pass
def fu0():
    d = bpy.data
    item = [d.images,d.textures,d.node_groups,
    d.materials,d.worlds,d.meshes,d.objects]
    for i in item:
        try:
            for ob in i:
                if ob.users < 1:                
                    try:
                        i.remove(ob, do_unlink = True)
                    except:
                        try:
                            i.remove(ob)
                        except:
                            pass
        except:
            pass
def fu1(mode):
    if 'EDIT' in mode:
        mode = 'EDIT'
    if 'TEXTURE' in mode:
        mode = 'TEXTURE_PAINT'
    if 'VERTEX' in mode:
        mode = 'VERTEX_PAINT'
    if 'WEIGHT' in mode:
        mode = 'WEIGHT_PAINT'    
    if 'PARTICLE' in mode:
        mode = 'PARTICLE_EDIT'
    try:
        bpy.ops.object.mode_set(mode= mode)
    except:
        print('unable to return to previous mode')
    return
def fu2(fn):    
    newName = ''.join(x for x in fn if x not in
    ',<>:""[]{}()/\|!@$%^&*,.?')    
    newName = newName.replace("-", " ")
    newName = newName.replace("_", " ")
    if len(newName) > 20:
        newName = newName.replace(" ", "")
    newName = newName[:18]
    for i in newName:
        if newName[:1] == ' ':
            newName = newName[1:]
    if len(newName) < 1:
        newName = "myBrush"
    newName = "°" + newName.title()    
    return newName
def fu3(brush, tex, fn, filepath, brushes):
    brush.zb_texscale = 50
    brush.zb_hardness = 50
    brush.zb_texscale_x = 0
    brush.zb_texscale_y = 0
    brush.zb_texscale_z = 0
    tool_settings = bpy.context.tool_settings
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    mode = bpy.context.mode
    if brushes == 1:
        newName = brush.name
    else:
        newName = fu2(fn)
        brush.name = newName
        brush.texture = tex
        brush.use_custom_icon = True
        brush.icon_filepath = filepath
    try: 
        brush.stroke_method = 'DOTS'
        brush.texture_slot.tex_paint_map_mode = 'TILED'
        brush.texture_overlay_alpha = 30
        brush.mask_overlay_alpha = 30
        tool_settings.image_paint.input_samples = 1
        tool_settings.sculpt.input_samples = 1
    except:
        pass
    if scene.zbLoadBrushType == 'decal':
        brush.name = '°Decal ' + newName[1:]
        try:
            brush.stroke_method = 'DRAG_DOT'
        except:
            pass    
        ts = brush.texture_slot
        ts.tex_paint_map_mode = 'VIEW_PLANE'
        ts.scale.xyz = 1.25
        img = brush.texture.image
        x = img.size[0]
        y = img.size[1]
        if x != y:
            lengths = [x,y]
            smallest = min(lengths)
            largest = max(lengths)
            percent = largest / smallest            
            if x == smallest:
                ts.scale[0] = ts.scale[0] * percent
            if y == smallest:
                ts.scale[1] = ts.scale[1] * percent
        brush.texture_overlay_alpha = 100
        brush.use_pressure_strength = False
        tex.extension = 'CLIP'
        brush.zb_hardness = 100
        if mode == "SCULPT":
            tex.use_color_ramp = True
            brush.texture.filter_size = 14
    if scene.zbLoadBrushType == 'stencil':
        brush.name = '°Stencil ' + newName[1:]
        brush.stroke_method = 'DOTS'
        brush.texture_slot.tex_paint_map_mode = 'STENCIL'
        brush.texture_slot.scale.xyz = 1
        brush.use_pressure_strength = False
        brush.texture_overlay_alpha = 30
        brush.mask_overlay_alpha = 50
        bpy.ops.object.zb_center_stencil()
    if scene.zbLoadBrushType == 'hard':
        brush.use_pressure_strength = False
        brush.zb_hardness = 100
    if bpy.context.mode == 'SCULPT':
        bpy.ops.brush.curve_preset(shape='LINE')
        brush.texture.filter_eccentricity = 64
        if scene.zbLoadBrushType != 'decal':
            brush.texture.filter_size = 2
        else:
            bpy.ops.brush.curve_preset(shape='MAX')
def load_zero_brush(context, filepath):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    settings = bpy.context.tool_settings
    mode = bpy.context.mode
    aType = bpy.context.area.type
    if aType == 'IMAGE_EDITOR':
        bpy.context.area.type = 'VIEW_3D'
        bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
        mode = bpy.context.mode
    if os.path.isdir(filepath):
        return
    else:
        fn = bpy.path.display_name_from_filepath(filepath)
        imgExists = False
        for image in bpy.data.images:
            if image.name in filepath:
                img = image
                imgExists = True
                break
        if imgExists == False:
            img = bpy.data.images.load(filepath)
            img.use_fake_user = True
        tex = bpy.data.textures.new(name =fn, type='IMAGE')
        tex.image = img 
        if 'PAINT' in mode:
            if mode == 'PAINT_TEXTURE':
                bpy.ops.brush.add()
                brush = bpy.context.tool_settings.image_paint.brush
                bpy.data.brushes[brush.name].image_tool = 'DRAW'       
            else:
                bpy.ops.brush.add()
                brush = bpy.context.tool_settings.vertex_paint.brush
                bpy.data.brushes[brush.name].vertex_tool = 'MIX'
            bpy.ops.brush.curve_preset(shape='SHARP')
            brush.color = (1, 1, 1)
            brush.strength = 1
        if 'SCULPT' in mode:
            bpy.ops.brush.add()
            brush = bpy.context.tool_settings.sculpt.brush
            bpy.data.brushes[brush.name].sculpt_tool = 'DRAW'
            bpy.ops.brush.curve_preset(shape='SHARP')
            brush.strength = 0.125
            brush.auto_smooth_factor = 0.15    
        if scene.zbLoadImgSculpt:
            if 'SCULPT' in mode:
                brush.use_paint_image = True
                brush.use_paint_vertex = True
            else:
                brush.use_paint_sculpt = True                
        brushes = 0 
        fu3(brush, tex, fn, filepath, brushes)
    fu1(mode)
    if aType == 'IMAGE_EDITOR':
        bpy.context.area.type = aType
        bpy.ops.object.mode_set(mode='EDIT')
    return {'FINISHED'}

class zbParticleDetailSelect(bpy.types.Operator):
    bl_idname = "ject.zb_particle_detail_select"
    bl_label = "Particle Detail Select"
    bl_description = "Select the type of particle children detail to increase or decrease (particle edit mode, object mode, render)"
    detailSelect = bpy.props.StringProperty()
    def execute(self,context):
        scene = bpy.context.scene
        dSel = self.detailSelect        
        scene.zbParticleDetailSelect = dSel    
        return{'FINISHED'}

class MaterialOptionsMenu(bpy.types.Menu):
    #bl_label =i_0[3]
    #bl_idname =i_0[4]
    #bl_description =i_0[5]
    bl_label = "Material Options" 
    bl_idname = "menu.zb_material_options_menu"
    bld_description = "Material operations like removing materials or uv maps from a selection."
    def draw(self, context):
        layout = self.layout
        col = layout.column()
        ob = bpy.context.active_object
        if ob:
            mat = ob.active_material
            col.menu('menu.zb_add_material',icon='ZOOMIN')
            col.operator('object.zb_material_operations',
            text='Remove Materials',icon='ZOOMOUT').op = 'REMOVE_MATERIALS'
            col.operator('object.zb_material_operations',
            text='Remove UV Maps',icon='ZOOMOUT').op = 'REMOVE_UVMAPS'
            col.menu('menu.zb_select_by_material',icon='HAND')
            if ob.active_material:
                col.separator()
                try:
                    col.operator("object.zb_make_unique", text="Make Unique", icon='MATERIAL')
                except:
                    pass
            else:
                try:
                    if ob.data.uv_textures.active.data[0].image:
                        col.separator()
                        col.operator('object.sf_apply_tex',text='Convert UV To Material', icon='MATERIAL')
                except:
                    pass  
        else:
            col.label('Material Operations (select object first)')

class MaterialAssignMenu(bpy.types.Menu):
    #bl_label =i_0[6]
    #bl_idname =i_0[7]
    #bl_description =i_0[8]
    bl_label="Assign Material"
    bl_idname="menu.zb_add_material"
    bl_description="Add a material to the selected object, objects or mesh." 
    def draw(self, context):
        layout = self.layout
        col = layout.column()        
        if len(bpy.data.materials) > 0:
            for mat in bpy.data.materials:
                col.operator('object.zb_material_operations',text=mat.name,
                icon='MATERIAL').op = mat.name + '__ZB__ADD_MATERIAL'
        else:
            col.label('No Materils Found In File',icon='MATERIAL')

class SelectByMaterialMenu(bpy.types.Menu):
    bl_label = "Select By Material" 
    bl_idname = "menu.zb_select_by_material" 
    bl_description = "Select all objects that are using the material from the list." 
    def draw(self, context):
        layout = self.layout
        col = layout.column()        
        if len(bpy.data.materials) > 0:
            for mat in bpy.data.materials:
                col.operator('object.zb_material_operations',text=mat.name,
                icon='MATERIAL').op = mat.name + '__ZB__SELECT_BY_MATERIAL'
        else:
            col.label('No Materils To Select From',icon='MATERIAL')   

class MaterialOperations(bpy.types.Operator):
    bl_label = "Material Operations"
    bl_idname = "object.zb_material_operations"
    bl_description = "Remove all materials from the selected objects."

    op = bpy.props.StringProperty()

    def execute(self,context):
        scene = bpy.context.scene
        mode = bpy.context.mode
        wm = bpy.context.window_manager
        ob = bpy.context.active_object
        selected = bpy.context.selected_objects
        op = self.op
        if 'ADD_MATERIAL' in op:
            mName = op.split('__ZB__ADD_MATERIAL')[0] 
            mat = bpy.data.materials[mName]
            if 'EDIT' in mode:
                if not ob.active_material:
                    bpy.ops.object.material_slot_add()
                if mName not in ob.data.materials:
                    ob.data.materials.append(mat)                
                i=0
                for m in ob.data.materials:
                    if ob.active_material == mat:
                        break
                    else:
                        ob.active_material_index = i
                        i+=1
                bpy.ops.object.material_slot_assign()
            else:             
                for ob in selected:                
                    ob.active_material = mat   
        if 'REMOVE_MATERIALS' in op:
            activeOb = bpy.context.active_object            
            for obj in selected:
                if hasattr(obj.data,'materials'):
                    scene.objects.active = obj                    
                    for m in obj.data.materials:
                        try:
                            bpy.ops.object.material_slot_remove()
                        except:
                            print('Could not remove material for',obj.name)
            scene.objects.active = ob
        if 'REMOVE_UVMAPS' in op:
            activeOb = bpy.context.active_object            
            for obj in selected:
                scene.objects.active = obj
                if hasattr(obj.data,'uv_textures'):
                    for uv in obj.data.uv_textures:
                        try:
                            bpy.ops.mesh.uv_texture_remove()
                        except:
                            print('Could not remove uv map for',obj.name)
            scene.objects.active = ob
        if 'SELECT_BY_MATERIAL' in op:
            mName = op.split('__ZB__SELECT_BY_MATERIAL')[0]
            for ob in bpy.data.objects:
                if hasattr(ob,'active_material'):
                    if hasattr(ob,'data'):
                        if hasattr(ob.data,'materials'):
                            if mName in ob.data.materials:
                                ob.select = True
                            else:
                                ob.select = False
                        else:
                            ob.select = False
                    else:
                        ob.select = False
                else:                        
                    ob.select = False
        return{'FINISHED'}

class cl4(bpy.types.Operator):
    bl_idname =i_0[15]
    bl_label =i_0[16]
    bl_description =i_0[17]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        scene = bpy.context.scene
        renEng = scene.render.engine
        scene = bpy.context.scene
        selected = bpy.context.selected_objects
        mode = bpy.context.mode
        for ob in selected:
            if ob.type == 'MESH':
                scene.objects.active = ob
                if ob.data.uv_textures:
                    img = ob.data.uv_textures.active.data[0].image                
                    bpy.ops.object.zb_paint_color()
                    mat = ob.active_material
                    mat.active_texture.image = img
                    imgNode = mat.node_tree.nodes['Image Texture zbColor']
                    imgNode.image = img
        fu1(mode)                    
        return {'FINISHED'}
def load_brushes_folder(context, filepath):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    aType = bpy.context.area.type
    settings = bpy.context.tool_settings
    mode = bpy.context.mode
    if aType == 'IMAGE_EDITOR':
        bpy.context.area.type = 'VIEW_3D'
        bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
        mode = bpy.context.mode
    if os.path.isdir(filepath):
        directory = filepath
    else:
        li = filepath.split(os.sep)
        directory = filepath.rstrip(li[-1])
    files = os.listdir(directory)
    for f in files:
        imgExists = False
        for blendImage in bpy.data.images:
            if blendImage.name in f:
                imgExists = True
                img = blendImage
                fn = f[3:] 
                tex = bpy.data.textures.new(name =fn, type='IMAGE')
                tex.use_fake_user =True
                tex.image = img 
                break
        if imgExists == False:
            try:
                fn = f[3:]
                img = bpy.data.images.load(filepath = directory +os.sep + f)
                img.use_fake_user =True
                tex = bpy.data.textures.new(name =fn, type='IMAGE')
                tex.use_fake_user =True
                tex.image = img 
            except:
                pass
            if bpy.context.mode.startswith('PAINT'):
                if mode == 'PAINT_TEXTURE':
                    bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
                    bpy.ops.brush.add()
                    brush = bpy.context.tool_settings.image_paint.brush
                    bpy.data.brushes[brush.name].image_tool = 'DRAW'
                else:
                    bpy.ops.object.mode_set(mode='VERTEX_PAINT')
                    bpy.ops.brush.add()
                    brush = bpy.context.tool_settings.vertex_paint.brush
                    bpy.data.brushes[brush.name].vertex_tool = 'MIX'
                bpy.ops.brush.curve_preset(shape='SHARP')
                brush.color = (1, 1, 1)
            if bpy.context.mode.startswith('SCULPT') is True:
                bpy.ops.object.mode_set(mode='SCULPT')
                bpy.ops.brush.add()
                brush = bpy.context.tool_settings.sculpt.brush
                bpy.data.brushes[brush.name].sculpt_tool = 'DRAW'
                bpy.ops.brush.curve_preset(shape='SHARP')
                brush.strength = 0.125
                brush.auto_smooth_factor = 0.15
            fn = bpy.path.display_name_from_filepath(directory +os.sep + f)
            newName = fu2(fn)
            brush.name = newName
            brush.texture = tex
            brush.use_custom_icon = True
            brush.icon_filepath = directory +os.sep + f
            brushes = 1
            if scene.zbLoadImgSculpt:
                if 'SCULPT' in mode:
                    brush.use_paint_image = True
                    brush.use_paint_vertex = True
                else:
                    brush.use_paint_sculpt = True
            fu3(brush, tex, fn, filepath, brushes)
    fu1(mode)
    if aType == 'IMAGE_EDITOR':
        bpy.context.area.type = aType
        bpy.ops.object.mode_set(mode='EDIT')
    return {'FINISHED'}

class zbLoadBrush(bpy.types.Operator, ImportHelper):
    #bl_idname =i_0[18]
    #bl_label =i_0[19]
    #bl_description =i_0[20]
    bl_idname = "texture.zb_load_brush"
    bl_label="Brush"
    bl_description="Load an image (png, jpeg, tiff, etc..) as a brush"
    @classmethod
    def poll(cls, context):
        return context.active_object != None
    def execute(self, context):
        return load_zero_brush(context, self.filepath)

class zbLoadBrushes(bpy.types.Operator, ImportHelper):
    #bl_idname =i_0[21]
    #bl_label =i_0[22]
    #bl_description =i_0[23]

    bl_idname = "texture.zb_load_brushes"
    bl_label = "Brushes"
    bl_description = "Load a folder of images (png, jpeg, tiff, etc..) as brushes"
    @classmethod
    def poll(cls, context):
        return context.active_object != None
    def execute(self, context):
        return load_brushes_folder(context, self.filepath)

class BrushMenu(bpy.types.Menu):
    #bl_label =i_0[24]
    #bl_idname =i_0[25]
    bl_label = ""
    bl_idname = "menu.zb_brush_menu"

    def draw(self, context):
        mode = bpy.context.mode
        ts = bpy.context.tool_settings
        aType = bpy.context.area.type
        layout = self.layout
        flow = layout.column_flow(columns=3)
        for brush in bpy.data.brushes:
            if mode == 'PAINT_TEXTURE' or aType == 'IMAGE_EDITOR':
                if brush.use_paint_image:
                    row = flow.row(align=True)
                    row.operator('object.zb_brush_context', text= brush.name,
                    icon_value=layout.icon(brush)).brushName = brush.name
            if mode == 'SCULPT':
                if brush.use_paint_sculpt:
                    row = flow.row(align=True)
                    row.operator('object.zb_brush_context', text= brush.name,
                    icon_value=layout.icon(brush)).brushName = brush.name
            if mode == 'PAINT_WEIGHT':
                if brush.use_paint_weight:
                    row = flow.row(align=True)
                    row.operator('object.zb_brush_context', text= brush.name,
                    icon_value=layout.icon(brush)).brushName = brush.name
            if mode == 'PAINT_VERTEX':
                if brush.use_paint_vertex:
                    row = flow.row(align=True)
                    row.operator('object.zb_brush_context', text= brush.name,
                    icon_value=layout.icon(brush)).brushName = brush.name
        if mode == 'PARTICLE':
            settings = ts.particle_edit
            brush = settings.brush
            tool = settings.tool
            tools = ['COMB','SMOOTH','ADD','LENGTH','PUFF','CUT']
            for tool in tools:
                row = flow.row()
                row.operator('object.zb_brush_context',
                text=tool.title(), icon='PARTICLEMODE').brushName = tool

class zbBrushContext(bpy.types.Operator):
    bl_label = "ZB Brush Context"
    bl_idname= "object.zb_brush_context"
    #bl_label =i_0[26]
    #bl_idname =i_0[27]
    brushName = bpy.props.StringProperty()
    def execute(self,context):
        scene = bpy.context.scene
        ts = bpy.context.tool_settings
        sd = bpy.context.space_data
        ups = ts.unified_paint_settings
        aType = bpy.context.area.type
        mode = bpy.context.mode
        wm = bpy.context.window_manager
        if mode == 'PAINT_TEXTURE' or aType == 'IMAGE_EDITOR':
            brush = bpy.data.brushes[self.brushName]
            paint = ts.image_paint
            if 'Fill' not in brush.name:
                wm.zbGradientSwitch = False
            else:
                brush.use_gradient = False
            ts.image_paint.brush = brush
            sd = bpy.context.space_data
            if scene.zbDistractionFreeMode:
                if hasattr(sd, 'show_only_render'):                
                    if 'Clone' in brush.name:
                        sd.show_only_render = False
                        self.report({'INFO'}, "Distraction Free Mode disabled when using Clone brush")
                    else:
                        sd.show_only_render = True
            if 'Smear' in brush.name:
                brush.stroke_method = 'DOTS'
            if 'Soften' in brush.name:
                brush.stroke_method = 'DOTS'
            if 'Clone' in brush.name:
                brush.stroke_method = 'DOTS'
            if 'Mask' in brush.name:
                if not paint.stencil_image:
                    bpy.ops.image.new(gen_context='PAINT_STENCIL')
                wm.zbViewMaskMode = 1
            else:
                if aType == 'VIEW_3D':
                    if sd.viewport_shade != 'TEXTURED':
                        sd.viewport_shade = 'MATERIAL'
            if 'Draw' in brush.name or 'Pen' in brush.name:
                paint.input_samples = 3
            else:
                paint.input_samples = 1
            if 'Graphic Pen' in brush.name:
                ups.use_pressure_size = True
            else:
                ups.use_pressure_size = False
        if mode == 'SCULPT':
            brush = bpy.data.brushes[self.brushName]
            ts.sculpt.brush = brush 
        if mode == 'PARTICLE':
            settings = ts.particle_edit
            settings.tool = self.brushName
            bpy.context.area.tag_redraw()
        if mode == 'PAINT_WEIGHT':
            sd.viewport_shade = 'SOLID'
            brush = bpy.data.brushes[self.brushName]
            ts.weight_paint.brush = brush 
        if mode == 'PAINT_VERTEX':
            brush = bpy.data.brushes[self.brushName]
            ts.vertex_paint.brush = brush 
        return{'FINISHED'}
def fu6(self,context):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    sd = bpy.context.space_data
    sculpt = bpy.context.mode.startswith('SCULPT')
    paint = bpy.context.mode.startswith('PAINT')
    re = scene.render.engine
    if sculpt:
        type = bpy.context.tool_settings.sculpt
    if paint:
        type = bpy.context.tool_settings.image_paint
    try: 
        type.brush.strength = 1
        type.brush.use_pressure_strength = False
    except:
        pass
    if wm.zbViewMaskMode:
        if re == 'BLENDER_RENDER':
            sd.viewport_shade = 'SOLID'
        else:
            sd.viewport_shade = 'TEXTURED'
        if sculpt:
            sd.viewport_shade = 'SOLID'
    else:
        if sd.viewport_shade != 'TEXTURED':
            sd.viewport_shade = 'MATERIAL'
        if sculpt:
            try:
                type.brush = bpy.data.brushes['SculptDraw']
            except:
                pass
        if paint:
            try:
                type.brush = bpy.data.brushes['Draw']
            except:
                pass
def fu7():
    scene = bpy.context.scene
    bpy.ops.object.mode_set(mode='OBJECT')
    realOb = bpy.context.active_object 
    mirror = len([mod for mod in realOb.modifiers if mod.type == 'MIRROR'])
    if mirror:
        try:
            bpy.ops.object.modifier_apply(apply_as='DATA', modifier="Mirror")
        except:
            pass
    armature = len([mod for mod in realOb.modifiers if mod.type == 'ARMATURE'])
    if armature < 1:
        bpy.ops.object.skin_armature_create(modifier="Skin") 
        ob = bpy.context.active_object 
        bones = bpy.context.object.data
        bones.use_auto_ik = True
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.armature.select_all(action='SELECT')
        bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        bpy.ops.object.mode_set(mode='POSE')
        if not bpy.context.active_object.pose_library:
            bpy.ops.poselib.new()
        bpy.ops.object.mode_set(mode='OBJECT')
        ob.name = realOb.name + "sBones" 
        bpy.context.active_object.select = False 
        bpy.context.object.hide = True 
        scene.objects.active = realOb 
    try:
        bpy.ops.object.modifier_apply(apply_as='DATA', modifier="Skin")
    except:
        pass
    realOb.select = True 
    bpy.context.space_data.use_occlude_geometry = True 
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.normals_make_consistent(inside=False)
    bpy.ops.mesh.vert_connect_nonplanar()
    bpy.ops.mesh.tris_convert_to_quads()
    bpy.ops.object.mode_set(mode='OBJECT')
    for x in range(20):
        bpy.ops.object.modifier_move_up(modifier="Armature") 
    return{'FINISHED'}
def zbDistractionFreeMode(self,context):
    mode = bpy.context.mode
    sd = bpy.context.space_data
    if mode in {'SCULPT', 'PAINT_TEXTURE'}:
        if self.zbDistractionFreeMode == False:
            sd.show_only_render = False
        else:
            sd.show_only_render = True
    return
class cl8(bpy.types.Operator):
    bl_idname =i_0[28]
    bl_label =i_0[29]
    bl_description =i_0[30]
    def execute(self,context):
        mode = bpy.context.mode
        bpy.ops.object.mode_set(mode='OBJECT')
        sel = bpy.context.selected_objects
        for ob in sel:
            removeMeta = False
            if ob.type == 'META':
                removeMeta = True
            try:                
                bpy.ops.object.convert(target='MESH')
                if removeMeta: 
                    for obj in bpy.data.objects:
                        if obj.type == 'META':
                            bpy.context.scene.objects.unlink(obj)
                    for obj in bpy.data.objects:    
                        if 'MBall' in obj.name:
                            obj.select = True
                            break
                bpy.ops.object.mode_set(mode='EDIT')                              
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.remove_doubles()
                bpy.ops.mesh.select_all(action='SELECT')
                bpy.ops.mesh.tris_convert_to_quads()
                bpy.ops.mesh.tris_convert_to_quads()
                bpy.ops.mesh.beautify_fill()
                if ob.type == 'FONT': 
                    bpy.ops.mesh.select_all(action='SELECT')
                    bpy.ops.uv.smart_project(island_margin = 0.03)
            except:
                pass
        fu1(mode)        
        return{'FINISHED'}
def zbPrecisePaintOption(self,context):
    wm = bpy.context.window_manager
    if self.zbPrecisePaintOption:
        needToSetUp = True
        for map in wm.keyconfigs.addon.keymaps:
            ki = map.keymap_items
            for key in ki:
                if 'ZB Rotate View' in key.name:
                    needToSetUp == False
        if needToSetUp:
            km = wm.keyconfigs.addon.keymaps.new(name='Image Paint', space_type='EMPTY')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'W','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'S','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'A','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'D','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'UP_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'DOWN_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'LEFT_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'RIGHT_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'UP_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'DOWN_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'LEFT_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'RIGHT_ARROW','PRESS')
            km = wm.keyconfigs.addon.keymaps.new('Sculpt', space_type='EMPTY')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'W','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'S','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'A','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint", 'D','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'UP_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'DOWN_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'LEFT_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'RIGHT_ARROW','PRESS',ctrl=True)
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'UP_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'DOWN_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'LEFT_ARROW','PRESS')
            kmi = km.keymap_items.new("object.zb_precise_paint_ctrl", 'RIGHT_ARROW','PRESS')
        addon_keymaps.append(km)
    else:
         for map in wm.keyconfigs.addon.keymaps:
            ki = map.keymap_items
            for key in ki:
                if 'ZB Precise Paint' in key.name:
                    key.active = False
    return
class zbPrecisePaint(bpy.types.Operator):
    bl_idname =i_0[31]
    bl_label =i_0[32]
    bl_description =i_0[33]
    counter = bpy.props.IntProperty()
    perspChoice = bpy.props.StringProperty(default='PERSP')
    def modal(self, context, event):
        if event.type == 'W':
            view3D = bpy.context.space_data.region_3d
            if self.counter < 1: 
                self.perspChoice = view3D.view_perspective
                bpy.ops.view3d.view_selected('INVOKE_DEFAULT')
                bpy.ops.view3d.viewnumpad('INVOKE_DEFAULT', type='FRONT')
            if self.counter%2 == 0:
                view3D.view_perspective = 'ORTHO'
                bpy.ops.view3d.view_orbit(type='ORBITDOWN')
                view3D.view_perspective = 'ORTHO'
            self.counter += 1
        if event.type == 'S':
            view3D = bpy.context.space_data.region_3d
            if self.counter < 1: 
                self.perspChoice = view3D.view_perspective
                bpy.ops.view3d.view_selected('INVOKE_DEFAULT')
                bpy.ops.view3d.viewnumpad('INVOKE_DEFAULT', type='BACK')
            if self.counter%2 == 0:
                view3D.view_perspective = 'ORTHO'
                bpy.ops.view3d.view_orbit(type='ORBITUP')
                view3D.view_perspective = 'ORTHO'
            self.counter += 1
        if event.type == 'A':
            view3D = bpy.context.space_data.region_3d
            if self.counter < 1: 
                self.perspChoice = view3D.view_perspective
                bpy.ops.view3d.view_selected('INVOKE_DEFAULT')
                bpy.ops.view3d.viewnumpad('INVOKE_DEFAULT', type='LEFT')
            if self.counter%2 == 0:
                view3D.view_perspective = 'ORTHO'
                bpy.ops.view3d.view_orbit(type='ORBITRIGHT')
                view3D.view_perspective = 'ORTHO'
            self.counter += 1
        if event.type == 'D':
            view3D = bpy.context.space_data.region_3d
            if self.counter < 1: 
                self.perspChoice = view3D.view_perspective
                bpy.ops.view3d.view_selected('INVOKE_DEFAULT')
                bpy.ops.view3d.viewnumpad('INVOKE_DEFAULT', type='RIGHT')
            if self.counter%2 == 0:
                view3D.view_perspective = 'ORTHO'
                bpy.ops.view3d.view_orbit(type='ORBITLEFT')
                view3D.view_perspective = 'ORTHO'
            self.counter += 1
        if event.type == 'LEFTMOUSE':
            if event.value == 'PRESS':
                if 'SCULPT' in bpy.context.mode:
                    bpy.ops.sculpt.brush_stroke('INVOKE_DEFAULT')
                else:
                    bpy.ops.paint.image_paint('INVOKE_DEFAULT')
        if event.type in {'X', 'F'}:
            if event.value == 'PRESS':
                if 'SCULPT' in bpy.context.mode:
                    bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                    data_path_primary = 'tool_settings.sculpt.brush.size',
                    rotation_path = 'tool_settings.sculpt.brush.texture_slot.angle',
                    color_path = 'tool_settings.sculpt.brush.cursor_color_add',
                    zoom_path = 'space_data.zoom',
                    image_id = 'tool_settings.sculpt.brush',
                    secondary_tex = False)
                else:
                    bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                    data_path_primary = 'tool_settings.image_paint.brush.size',
                    data_path_secondary = 'tool_settings.unified_paint_settings.size',
                    use_secondary = 'tool_settings.unified_paint_settings.use_unified_size',
                    rotation_path = 'tool_settings.image_paint.brush.mask_texture_slot.angle',
                    color_path = 'tool_settings.image_paint.brush.cursor_color_add',
                    fill_color_path = 'tool_settings.image_paint.brush.color',
                    zoom_path = 'space_data.zoom',
                    image_id = 'tool_settings.image_paint.brush',
                    secondary_tex = False)
        if event.ctrl:
            if event.type in {'X', 'F'}:
                if event.value == 'PRESS':
                    if 'SCULPT' in bpy.context.mode:
                        bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                        data_path_primary = 'tool_settings.sculpt.brush.texture_slot.angle',
                        rotation_path = 'tool_settings.sculpt.brush.texture_slot.angle',
                        color_path = 'tool_settings.sculpt.brush.cursor_color_add',
                        image_id = 'tool_settings.sculpt.brush',
                        secondary_tex=False)
                    else:
                        bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                        data_path_primary = 'tool_settings.image_paint.brush.texture_slot.angle',
                        rotation_path = 'tool_settings.image_paint.brush.texture_slot.angle',
                        color_path = 'tool_settings.image_paint.brush.cursor_color_add',
                        fill_color_path = 'tool_settings.image_paint.brush.color',
                        image_id = 'tool_settings.image_paint.brush',
                        secondary_tex=False)
            if event.type == 'Z':
                if self.counter%2 == 0:
                    bpy.ops.ed.undo()
                self.counter+= 1
            try:
                if 'SCULPT' in bpy.context.mode:
                    brush = bpy.context.tool_settings.sculpt.brush
                else:
                    brush = bpy.context.tool_settings.image_paint.brush
                if event.type == 'DOWN_ARROW':
                    brush.stencil_pos.y -=  0.1
                if event.type == 'UP_ARROW':
                    brush.stencil_pos.y +=  0.1
                if event.type == 'RIGHT_ARROW':
                    brush.stencil_pos.x +=  0.1
                if event.type == 'LEFT_ARROW':
                    brush.stencil_pos.x -=  0.1
            except:
                pass
        if event.shift:
            if event.type in {'X', 'F'}:
                if event.value == 'PRESS':
                    if 'SCULPT' in bpy.context.mode:
                        bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                        data_path_primary = 'tool_settings.sculpt.brush.strength',
                        rotation_path = 'tool_settings.sculpt.brush.texture_slot.angle',
                        color_path = 'tool_settings.sculpt.brush.cursor_color_add',
                        image_id = 'tool_settings.sculpt.brush',
                        secondary_tex = False)
                    else:
                        bpy.ops.wm.radial_control('INVOKE_DEFAULT',
                        data_path_primary = 'tool_settings.image_paint.brush.strength',
                        data_path_secondary = 'tool_settings.unified_paint_settings.strength',
                        use_secondary = 'tool_settings.unified_paint_settings.use_unified_strength',
                        rotation_path = 'tool_settings.image_paint.brush.mask_texture_slot.angle',
                        color_path = 'tool_settings.image_paint.brush.cursor_color_add',
                        fill_color_path = 'tool_settings.image_paint.brush.color',
                        image_id = 'tool_settings.image_paint.brush',
                        secondary_tex = False)
            if event.ctrl:
                if event.alt:
                    if event.type == 'SPACE':
                        if event.value == 'PRESS':
                            bpy.ops.view3d.zoom('INVOKE_DEFAULT')
            if event.type == 'MIDDLEMOUSE':
                if event.value == 'PRESS':
                    bpy.ops.view3d.move('INVOKE_DEFAULT')
            if event.type == 'RIGHTMOUSE':
                bpy.ops.brush.stencil_control('INVOKE_DEFAULT', mode='SCALE')
        if event.type == 'WHEELUPMOUSE':
            bpy.ops.view3d.zoom(delta = 1)
        if event.type == 'WHEELDOWNMOUSE':
            bpy.ops.view3d.zoom(delta = -1)
        if event.type == 'RIGHTMOUSE':
            if 'SCULPT' in bpy.context.mode:
                brush = context.tool_settings.sculpt.brush
            else:
                brush = context.tool_settings.image_paint.brush
            if brush.texture_slot.tex_paint_map_mode == 'STENCIL':
                if event.value == 'PRESS':
                    bpy.ops.brush.stencil_control('INVOKE_DEFAULT', mode='TRANSLATION')
            else:
                self.counter = 0
                view3D = bpy.context.space_data.region_3d
                view3D.view_perspective = self.perspChoice
                return{'FINISHED'}
        if event.type =='SPACE':
            if event.value == 'RELEASE':
                bpy.ops.wm.call_menu(name='menu.zb_brush_menu')
        if event.ctrl == False:
            if event.type == 'DOWN_ARROW':
                if self.counter%2 == 0:
                    bpy.ops.view3d.view_pan(type='PANDOWN')
                self.counter += 1
            if event.type == 'UP_ARROW':
                if self.counter%2 == 0:
                    bpy.ops.view3d.view_pan(type='PANUP')
                self.counter += 1
            if event.type == 'RIGHT_ARROW':
                if self.counter%2 == 0:
                    bpy.ops.view3d.view_pan(type='PANRIGHT')
                self.counter += 1
            if event.type == 'LEFT_ARROW':
                if self.counter%2 == 0:
                    bpy.ops.view3d.view_pan(type='PANLEFT')
                self.counter += 1
        if event.type == 'MIDDLEMOUSE':
            if event.value == 'PRESS':
                if event.shift == False:
                    self.counter = 0
                    view3D = bpy.context.space_data.region_3d
                    view3D.view_perspective = self.perspChoice
                    bpy.ops.view3d.rotate('INVOKE_DEFAULT')
                    return{'FINISHED'}
        if event.type in {'ESC','ZERO','ONE','TWO','THREE',
        'FOUR','FIVE','SIX','SEVEN','EIGHT','NINE'}:
            self.counter = 0
            view3D = bpy.context.space_data.region_3d
            view3D.view_perspective = self.perspChoice
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}
class cl9(bpy.types.Operator):
    bl_idname =i_0[34]
    bl_label =i_0[35]
    bl_description = "Pan brush stencil up, down, left, right with\
 very tight precision"
    def modal(self, context, event):
        if event.ctrl:
            try:
                brush = bpy.context.tool_settings.image_paint.brush
                if event.type == 'DOWN_ARROW':
                    brush.stencil_pos.y -=  0.1
                    return {'FINISHED'}
                if event.type == 'UP_ARROW':
                    brush.stencil_pos.y +=  0.1
                    return {'FINISHED'}
                if event.type == 'RIGHT_ARROW':
                    brush.stencil_pos.x +=  0.1
                    return {'FINISHED'}
                if event.type == 'LEFT_ARROW':
                    brush.stencil_pos.x -=  0.1
                    return {'FINISHED'}
            except:
                pass
        if event.ctrl == False:
            if event.type == 'DOWN_ARROW':
                bpy.ops.view3d.view_pan(type='PANDOWN')
                return {'FINISHED'}
            if event.type == 'UP_ARROW':
                bpy.ops.view3d.view_pan(type='PANUP')
                return {'FINISHED'}
            if event.type == 'RIGHT_ARROW':
                bpy.ops.view3d.view_pan(type='PANRIGHT')
                return {'FINISHED'}
            if event.type == 'LEFT_ARROW':
                bpy.ops.view3d.view_pan(type='PANLEFT')
                return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}
class cl10(bpy.types.Operator):
    bl_idname =i_0[36]
    bl_label =i_0[37]
    bl_description =i_0[38]
    modeButton = bpy.props.IntProperty()
    @classmethod
    def poll(cls, context):
        ob = bpy.context.active_object
        abortOp = False
        try:
            ob.library.users
            abortOp = True
        except:     
            try:
                ob.data.library.users
                abortOp = True
            except:
                pass        
        return abortOp == False
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        re = scene.render.engine
        mode = bpy.context.mode
        sd = bpy.context.space_data
        userMsg = ''
        try:
            ob = bpy.context.active_object
            mat = ob.active_material
        except:
            ob = 0
            mat = 0
        if scene.zbDistractionFreeMode:
            try:
                if ob.type == 'MESH':
                    if self.modeButton == 2 or self.modeButton == 3:
                        if "PAINT" not in mode and "SCULPT" not in mode:
                            sd.show_only_render = True
                            ob.hide_render = False
                    else:
                        if self.modeButton < 5:
                            sd.show_only_render = False
            except:
                pass
        if ob:                        
            if self.modeButton != 3 and self.modeButton < 5:
                if bpy.context.image_paint_object:
                    if scene.zbAutoSaveLayers:                        
                        bpy.ops.object.zb_save_layers(save_only_active=True)
                        userMsg = "Paint layers saved."
            if self.modeButton == 1:
                try: 
                    ob.modifiers["Multires"].show_viewport = True
                except:
                    pass
                bpy.ops.object.mode_set(mode='OBJECT')
            elif self.modeButton == 2:
                if scene.zbDisableShadows:
                    scene.zbDisableShadows = True
                else:
                    scene.zbDisableShadows = False
                if ob.type != 'MESH':
                    mType = ['SURFACE','FONT','META','CURVE']
                    for m in mType:
                        if m in ob.type:
                            bpy.ops.object.sf_convert()
                            ob = bpy.context.active_object
                            break
                if ob.type == 'MESH':
                    try: 
                        ob.modifiers["Multires"].show_viewport = True
                    except:
                        pass
                    try: 
                        bpy.ops.object.transform_apply(scale=True)
                    except:
                        pass
                    bpy.ops.object.mode_set(mode='SCULPT')
                    if scene.zbFastMode:
                        sd.viewport_shade = 'SOLID'
                else:
                    userMsg = "This mode is only for mesh objects."
            elif self.modeButton == 3:
                if scene.zbDisableShadows:
                    scene.zbDisableShadows = True
                else:
                    scene.zbDisableShadows = False
                scene.zbPrecisePaintOption = scene.zbPrecisePaintOption
                if ob.type != 'MESH':
                    mType = ['SURFACE','FONT','META','CURVE']
                    for m in mType:
                        if m in ob.type:
                            bpy.ops.object.sf_convert()
                            ob = bpy.context.active_object
                            break
                if ob.type == 'MESH':                 
                    if re == 'CYCLES':
                        if scene.zbGoCycles == False:
                            scene.zbGoCycles = True
                    else:
                        if scene.zbGoCycles:
                            scene.zbGoCycles = False
                    skin = len([mod for mod in ob.modifiers if mod.type == 'SKIN'])
                    if skin:
                        fu7()
                        userMsg = "APPLIED SKIN: Click 'EYE' icon next to" + ob.name + " in the outliner to see it."
                    hasPaint = False
                    if ob.data.uv_textures:
                        if mat is not None:
                            for ts in mat.texture_slots:
                                if ts is not None:
                                    try:
                                        if ts.texture.type == 'IMAGE':
                                            if ts.texture.image:
                                                hasPaint = True
                                                break
                                    except:
                                        pass    
                            if hasPaint == False:
                                if mat.use_nodes:
                                    if mat.node_tree.nodes:
                                        if 'Image Texture' in mat.node_tree.nodes:
                                            hasPaint = True                                                                     
                    if scene.zbAState:                    
                        needsPaint = True                                                
                        fu8(ob)
                        mat = ob.active_material
                        if mat:
                            if 'ZB Painted' in mat.name:
                                needsPaint = False     
                            if hasattr(mat.node_tree, 'nodes'):      
                                if 'Image Texture zbColor' in mat.node_tree.nodes:
                                    needsPaint = False
                            if needsPaint:  
                                hasPaint = True                              
                                if re == 'BLENDER_RENDER':
                                    if ' Painted' in mat.name:                   
                                        userMsg = 'Can not paint Blender Render materials after Alchemy material painting.'
                                        sd.show_only_render = False                                    
                                    else:                                    
                                        bpy.ops.object.zb_alchemy_paint() 
                                if re == 'CYCLES':
                                    if 'ZBA Painted' in mat.name:                                
                                        userMsg = 'Material to complex, can no longer texture paint'
                                        sd.show_only_render = False
                                    else:
                                        bpy.ops.object.zb_alchemy_paint() 
                                fu11()                       
                    if hasPaint:
                        try:
                            scene.game_settings.material_mode = 'GLSL'                                        
                        except:
                            pass
                    else:      
                        if scene.zbAState == False:                            
                            for sl in ob.material_slots:
                                if not sl.material:
                                    i = 0
                                    for sl in ob.material_slots:
                                        ob.active_material_index = i
                                        if not sl.material:
                                            break
                                        else:
                                            i += 1
                                    break     
                        bpy.ops.object.zb_paint_color()
                    if sd.viewport_shade != 'TEXTURED':
                        sd.viewport_shade = 'MATERIAL'
                    bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
                    try: 
                        ob = bpy.context.active_object
                        for mod in ob.modifiers:
                            if mod.type == 'BEVEL':
                                if mod.show_viewport == True:
                                    bpy.ops.object.mode_set(mode='OBJECT')
                                    mod.show_viewport = True
                                    if userMsg == '':
                                        bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
                                    break
                            if mod.type == 'MULTIRES':
                                mod.show_viewport = True
                    except:
                        pass
                else:
                    userMsg = "This mode is only for mesh objects."
            elif self.modeButton == 4:
                if scene.zbFastMode:
                     try:
                         ob.modifiers["Multires"].show_viewport = False
                     except:
                         pass
                skin = len([mod for mod in ob.modifiers if mod.type == 'SKIN'])
                if skin:
                    fu7()
                    userMsg = "APPLIED SKIN: Click 'EYE' icon next to" + ob.name + " in the outliner to see it."
                report = 0
                for type in ob.modifiers:
                    try:
                        if "Bones" not in type.object.name:
                            report = 1
                            break
                    except:
                        pass
                if report == 1:
                    userMsg = "Object already has armature. None created for it."
                try: 
                    if bpy.context.active_object.type == 'MESH':
                        if context.active_object.particle_systems.active is None:
                            bpy.ops.object.zb_add_strands(option = 'NEW')
                        bpy.ops.object.mode_set(mode='PARTICLE_EDIT')
                    else:
                        userMsg = "This mode is not available for this type of object."
                except:
                    pass
        else:
            if ob: 
                if bpy.context.mode != 'POSE':
                    bpy.ops.object.mode_set(mode='OBJECT')
            if self.modeButton != 1:
                if self.modeButton != 6:
                    userMsg = "This mode is only for mesh objects."
        if scene.zbDisableShadows:
            if self.modeButton > 3 or self.modeButton < 2:
                for lamp in bpy.data.lamps:
                    try:
                       lamp.shadow_method = 'RAY_SHADOW'
                    except:
                        pass
        if self.modeButton == 6:
            bpy.ops.screen.screen_full_area()
        for brush in bpy.data.brushes:
            if 'Decal'.lower() in brush.name.lower():
                if brush.use_paint_sculpt:
                    if brush.use_paint_image:
                        tex = brush.texture
                        if mode == 'PAINT_TEXTURE':
                            tex.use_color_ramp = True
                        if mode == 'SCULPT':
                            tex.use_color_ramp = False
        if userMsg:
            self.report({'INFO'}, userMsg)
        return{'FINISHED'}
class cl11(bpy.types.Operator):
    bl_idname =i_0[39]
    bl_label =i_0[40]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self,context):     
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        renEng = scene.render.engine
        ob = bpy.context.active_object
        fu8(ob)        
        mat = ob.active_material                
        origMat = mat.name                      
        newMatName = ' ZB Painted'
        dispMeth = ''
        if hasattr(mat.cycles,'displacement_method'):
            dispMeth = mat.cycles.displacement_method                  
        if renEng == 'BLENDER_RENDER':      
            mat.name = mat.name + newMatName
            if ob.data.uv_textures is False:
                bpy.ops.object.mode_set(mode='EDIT')
                useSeams = False
                for edge in ob.data.edges:
                    if edge.use_seam:
                        useSeams = True
                        bpy.ops.uv.unwrap()
                        break
                if useSeams is False:
                    bpy.ops.mesh.select_all(action='SELECT')
                    if scene.zbUseLightMap:
                        bpy.ops.uv.lightmap_pack(PREF_MARGIN_DIV=0.3)
                    else:
                        bpy.ops.uv.smart_project(island_margin = 0.03, 
                        angle_limit = 45)
            if mat.use_diffuse_ramp:
                mat.diffuse_ramp_blend = 'DIVIDE'
            layerType = "Color"
            texCol = 0.9
            texOpas = 0
            alphaChoice = True
            normalChoice = True
            mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
            normalChoice)
        else: 
            aType = bpy.context.area.type
            bpy.context.area.type = 'NODE_EDITOR'
            bpy.context.space_data.tree_type = 'ShaderNodeTree'
            bpy.context.space_data.shader_type = 'OBJECT'
            bpy.ops.wm.redraw_timer(type='DRAW_WIN', iterations=0)
            activeMat = mat
            g1_vol = 0
            g1_dis = 0
            g1_surf = 0
            for node in activeMat.node_tree.nodes:
                if node.type == 'OUTPUT_MATERIAL':
                    node.select = False
                    if node.inputs['Surface'].links:
                        l = node.inputs['Surface'].links[0]
                        g1_surf = l.from_socket.name   
                    if node.inputs['Volume'].links:
                        l = node.inputs['Volume'].links[0]
                        g1_vol = l.from_socket.name                        
                    if node.inputs['Displacement'].links:
                        l = node.inputs['Displacement'].links[0]
                        g1_dis = l.from_socket.name
                else:
                    node.select = True
            allGroups = []
            for g in bpy.data.node_groups:
                allGroups.append(g.name)
            bpy.ops.node.group_make()
            bpy.ops.node.tree_path_parent()
            bpy.ops.node.group_ungroup()
            newGroup = 0
            for group in bpy.data.node_groups:
                if group.name not in allGroups:
                    group01 = group
                    group01.tag = True
                    break                                      
            group01.name = activeMat.name + ' Alchemy Material ZB'
            bpy.context.area.type = aType            
            bpy.ops.object.material_slot_add()
            layerType = "Color"
            texCol = 0.9
            texOpas = 0
            alphaChoice = True
            normalChoice = True
            mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
            normalChoice)
            mat = ob.active_material
            if ' Painted' in mat.name:
                mn1 = split(' Painted')[0]        
                mat.name = mn1 + newMatName 
            else:
                mat.name = mat.name + newMatName
            i = 0 
            ob.active_material_index = 0
            for slot in ob.material_slots:
                if ob.active_material.name == origMat:
                    bpy.ops.object.material_slot_remove()
                    break
                else:
                    ob.active_material_index = i
                i += 1
            i = 0 
            for i in ob.material_slots:
                try:
                    if ob.active_material:
                        if ' ZB Painted' in ob.active_material.name:
                            ob.active_material_index = i
                            mat = ob.active_material
                        break
                except:
                    pass
            nodes = mat.node_tree.nodes
            for node in nodes:
                if node.type == 'OUTPUT_MATERIAL':
                    nodeOutput = node   
                if node.name == 'Image Texture zbColor':
                    nodeImgTex = node   
                if node.name == 'Diffuse BSDF zbColor':
                    nodeZBColor = node  
                if node.name == 'Mixed1':
                    nodeMixed1 = node 
                if node.name == 'Mixed8':
                    nodeMixed8 = node
                if node.name == 'Bright/Contrast zbColor':
                    nodeImgOut = node
                if node.name == 'Math zbBump':
                    nodeZBBump = node
                if node.name == 'Math zbDisplace':
                    nodeZBDisplace = node
            nodeGroup = nodes.new(type = 'ShaderNodeGroup')
            nodeGroup.node_tree = group01
            nodeGroup.location = (-50, 225)
            nodeInvert = nodes.new(type = 'ShaderNodeInvert')
            nodeInvert.location = (-50, 105)
            nodeMixed0 = nodes.new(type = 'ShaderNodeMixShader')
            nodeMixed0.label = 'Mixed0'
            nodeMixed0.name = 'Mixed0'
            nodeMixed0.location = (505, 135)
            nodeBW = nodes.new(type = 'ShaderNodeRGBToBW')
            nodeBW.location = (2250, -125)
            nodeMixDis = nodes.new(type = 'ShaderNodeMixRGB')
            nodeMixDis.name = 'Mix Alchemy Displacement'
            nodeMixDis.label = 'Mix Alchemy Displacement'
            nodeMixDis.location = (2500, -288) 
            link = mat.node_tree.links 
            link.new(nodeGroup.outputs[g1_surf], nodeMixed0.inputs[2]) 
            link.new(nodeMixed0.outputs['Shader'], nodeMixed1.inputs[1])  
            link.new(nodeZBColor.outputs['BSDF'], nodeMixed0.inputs[1]) 
            link.new(nodeImgTex.outputs['Alpha'], nodeInvert.inputs['Color'])
            link.new(nodeInvert.outputs['Color'], nodeMixed0.inputs['Fac'])        
            link.new(nodeImgOut.outputs['Color'], nodeBW.inputs['Color'])
            link.new(nodeMixDis.outputs['Color'],nodeZBDisplace.inputs[1])
            if nodeZBDisplace.inputs[1].links[0].from_node.name == 'Math zbBump':
                link.new(nodeZBBump.outputs['Value'], nodeMixDis.inputs[1])
            if g1_dis:
                link.new(nodeBW.outputs['Val'], nodeMixDis.inputs['Fac'])                         
                link.new(nodeGroup.outputs[g1_dis], nodeMixDis.inputs[1])
                link.new(nodeGroup.outputs[g1_dis], nodeMixDis.inputs[2])
            if g1_vol:
                try:
                    if nodeGroup.outputs[g1_vol] == nodeGroup.outputs[0]: 
                        if nodeGroup.outputs[1] == 'Displacement':
                            link.new(nodeGroup.outputs[2],nodeOutput.inputs['Volume'])
                        else:                           
                            link.new(nodeGroup.outputs[1],nodeOutput.inputs['Volume'])
                    else:
                        link.new(nodeGroup.outputs[g1_vol],nodeOutput.inputs['Volume'])
                except:
                    pass
            i = 0 
            for mat in ob.data.materials:
                ob.active_material_index = i
                if 'ZB Painted' not in ob.active_material.name:
                    bpy.ops.object.material_slot_remove()
                else:
                    i += 1
            if dispMeth:
                mat.cycles.displacement_method = dispMeth
        return{'FINISHED'}
def fu8(ob):
    i = 0 
    for slot in ob.material_slots:
        ob.active_material_index = i    
        if hasattr(ob.active_material,'name'):
            i+=1
        else:
            print('removing material slot',i)
            bpy.ops.object.material_slot_remove()
    ob.active_material_index = 0    
def fu9(self, context):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    sd = bpy.context.space_data
    ren = scene.render
    origSelected = bpy.context.selected_objects
    origActive = bpy.context.active_object.name
    if self.zbFastMode:
        if sd.viewport_shade == 'MATERIAL':
            sd.viewport_shade = 'TEXTURED'
        ren.use_simplify = True
        if wm.zbLampBufferSize == 0: 
            ren.simplify_child_particles = 0.0
            ren.simplify_shadow_samples = 1
            ren.simplify_ao_sss = 0.15
            ren.simplify_subdivision = 3
        for lamp in bpy.data.lamps:
            if lamp.type != 'HEMI':
                if lamp.shadow_buffer_size > 0:
                    if lamp.shadow_buffer_size != 128:
                        wm.zbLampBufferSize = lamp.shadow_buffer_size
                    lamp.shadow_buffer_size = 128
        scene.tool_settings.sculpt.show_low_resolution = True
        if context.sculpt_object:
            sd.viewport_shade = 'SOLID'
        if context.particle_edit_object:
            try:
                bpy.context.object.modifiers["Multires"].show_viewport = False
            except:
                pass
        else:
            try:
                bpy.context.object.modifiers["Multires"].show_viewport = True
            except:
                pass
        try: 
            sel = bpy.context.selected_objects
            bpy.ops.object.select_all(action='DESELECT')
            for ob in bpy.data.objects:
                for mod in ob.modifiers:
                    if mod.type == 'BEVEL':
                        mod.show_viewport = False
                        ob.select = True
                        bpy.ops.object.shade_flat()
            bpy.ops.object.select_all(action='DESELECT')
            for ob in sel:
                ob.select = True
        except:
            pass
        if len(bpy.context.screen.areas) < 3:
            bpy.ops.screen.screen_full_area() 
        if bpy.context.screen.name in {'Blender','Hacker'}:
            v3d_list = [area for area in bpy.context.screen.areas if area.type == 'VIEW_3D']
            if v3d_list:
                if len(v3d_list) > 1:
                    smallest_area = min(v3d_list, key=lambda area: area.width * area.height)
                    smallest_area.spaces.active.viewport_shade = 'BOUNDBOX'
                largest_area = max(v3d_list, key=lambda area: area.width * area.height)
                largest_area.spaces.active.show_backface_culling = True
    else: 
        ren.use_simplify = False
        scene.tool_settings.sculpt.show_low_resolution = False
        if sd.viewport_shade == 'TEXTURED':
            sd.viewport_shade = 'MATERIAL'
        try: 
            ob = bpy.context.active_object
            for mod in ob.modifiers:
                if mod.type == 'MULTIRES':
                    mod.show_viewport = True
                    break
        except:
            pass
        for lamp in bpy.data.lamps:
            if lamp.type != 'HEMI':
                if lamp.shadow_buffer_size > 0:
                    lamp.shadow_buffer_size = wm.zbLampBufferSize
        try: 
            sel = bpy.context.selected_objects
            bpy.ops.object.select_all(action='DESELECT')
            for ob in bpy.data.objects:
                for mod in ob.modifiers:
                    if mod.type == 'BEVEL':
                        mod.show_viewport = True
                        ob.select = True
                        bpy.ops.object.shade_smooth()
            bpy.ops.object.select_all(action='DESELECT')
            for ob in sel:
                ob.select = True
        except:
            pass
        if len(bpy.context.screen.areas) < 3:
            bpy.ops.screen.screen_full_area()            
        for screen in bpy.data.screens:
            for area in screen.areas:                
                if area.type == 'VIEW_3D':
                    if area.spaces.active.viewport_shade == 'BOUNDBOX':
                        area.spaces.active.viewport_shade = 'MATERIAL'
                        area.spaces.active.show_backface_culling = False
    for obj in bpy.context.selected_objects:
        obj.select = False
    for obj in origSelected:
        obj.select = True    
    scene.objects.active = bpy.data.objects[origActive]
def fu10(ob):
    scene = bpy.context.scene
    ob.update_from_editmode()
    seamsUsed = False
    mesh = ob.data
    if ob.data.uv_textures:
        print('Used',ob.name+"'s existing uv map")
    else:
        for e in mesh.edges:
            if e.use_seam:
                seamsUsed = True
                break
        if seamsUsed:
            if bpy.context.mode != 'EDIT_MESH':
                bpy.ops.object.editmode_toggle()
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.uv.unwrap()
            bpy.ops.object.editmode_toggle()
        else: 
            if scene.zbUseLightMap:
                bpy.ops.uv.lightmap_pack(PREF_MARGIN_DIV=0.3)
            else:
                bpy.ops.uv.smart_project(island_margin = 0.03, angle_limit = 15)
def fu11():
    try:
        ob = bpy.context.active_object
        mat = ob.active_material
        img = mat.active_texture.image
        x = -1
        for slot in mat.texture_paint_images:
            x += 1
            if slot == img:
                mat.paint_active_slot = x
                break
    except:
        pass
def fu12(context,tn):
    try:
        ob = bpy.context.active_object
        me = ob.data
        mat = ob.active_material
        mat.active_texture_index = tn
        ts = mat.texture_slots[tn]
        try:  
            ts.use = True
        except:
            pass
        if not me.uv_textures:
            bpy.ops.mesh.uv_texture_add()
        if ts.texture_coords  == 'UV':
            if ts.uv_layer:
                uvtex = me.uv_textures[ts.uv_layer]
            else:
                uvtex = me.uv_textures.active
                me.uv_textures.active= uvtex
        else:
            uvtex = me.uv_textures.active
        uvtex = uvtex.data.values()
        img = ts.texture.image
        m_id = ob.active_material_index
        if img:
            for f in me.polygons:
                if f.material_index == m_id:
                    uvtex[f.index].image = img
        else:
            for f in me.polygons:
                if f.material_index == m_id:
                    uvtex[f.index].image = None
        fu11()
        me.update()
    except:
        pass
    try:
        if "color" in img.name.lower() :
            node = mat.node_tree.nodes['Image Texture zbColor']
        if "bump" in img.name.lower() :
            node = mat.node_tree.nodes['Image Texture zbBump']
        if "specular" in img.name.lower() :
            node = mat.node_tree.nodes['Image Texture zbSpecular']
        if "glow" in img.name.lower() :
            node = mat.node_tree.nodes['Image Texture zbGlow']
        if "alpha_mask" in img.name.lower() :
            node = mat.node_tree.nodes['Image Texture zbAlpha_Mask']
        node.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = node
        me.update()
    except:
        pass
    return
class cl12(bpy.types.Operator):
    bl_idname =i_0[41]
    bl_label =i_0[42]
    bl_description =i_0[43]
    tex_index = IntProperty(name = 'tex_index', default = 0)
    @classmethod
    def poll(cls, context):
        return context.active_object != None
    def execute(self, context):
        tn = self.tex_index
        fu12(context, tn)
        return {'FINISHED'}
class cl13(bpy.types.Operator):
    bl_idname =i_0[44]
    bl_label =i_0[45]
    bl_description =i_0[46]
    def modal(self, context, event):
        paint = bpy.context.mode.startswith('PAINT_TEXTURE')
        weight = bpy.context.mode.startswith('PAINT_WEIGHT')
        vertex = bpy.context.mode.startswith('PAINT_VERTEX')
        aType = bpy.context.area.type
        wm = bpy.context.window_manager
        if event.value == 'RELEASE':
            if paint or aType == 'IMAGE_EDITOR':
                brush = bpy.context.tool_settings.image_paint.brush
                brushBlend = wm.zbLastBrushBlend
                if brushBlend == "ERASE_ALPHA":
                    brushBlend = "MIX"
                try:
                    bpy.context.tool_settings.image_paint.brush.blend = brushBlend
                except:
                    pass
                if brush is not None:
                    if 'Mask' in brush.name:
                        brush.weight = 1
            if weight:
                brush = bpy.context.tool_settings.weight_paint.brush
                brush.vertex_tool = 'ADD'
            if vertex:
                brush = bpy.context.tool_settings.vertex_paint.brush
                brush.vertex_tool = 'MIX'
                if event.ctrl is False:
                    brush.color = (0,0,0)                        
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        context.window_manager.modal_handler_add(self)
        paint = bpy.context.mode.startswith('PAINT_TEXTURE')
        weight = bpy.context.mode.startswith('PAINT_WEIGHT')
        vertex = bpy.context.mode.startswith('PAINT_VERTEX')
        aType = bpy.context.area.type
        wm = bpy.context.window_manager
        try:
            if paint or aType == 'IMAGE_EDITOR':
                ob = bpy.context.active_object
                img = 0                
                try:
                    mat = ob.active_material  
                    img = mat.active_texture.image
                except:
                    pass
                brush = bpy.context.tool_settings.image_paint.brush
                brushBlend = brush.blend
                wm.zbLastBrushBlend = brushBlend
                if 'Mask' in brush.name:
                    brush.weight = 0
                else:
                    if img:                    
                        if 'Bump' in img.name:
                            brush.blend = 'SUB'
                        else:
                            brush.blend = 'ERASE_ALPHA'
                    else:
                        brush.blend = 'ERASE_ALPHA'
            if weight:
                brush = bpy.context.tool_settings.weight_paint.brush
                brush.vertex_tool = 'SUB'
            if vertex:
                brush = bpy.context.tool_settings.vertex_paint.brush
                if event.ctrl:
                    brush.vertex_tool = 'BLUR'
                else:                                        
                    brush.vertex_tool = 'MIX'  
                    brush.color = (1,1,1)
        except:
            pass
        if paint or aType == 'IMAGE_EDITOR':
            bpy.ops.paint.image_paint('INVOKE_DEFAULT')
        if weight:
            bpy.ops.paint.weight_paint('INVOKE_DEFAULT')
        if vertex:
            bpy.ops.paint.vertex_paint('INVOKE_DEFAULT')
        return {'RUNNING_MODAL'}
class cl14(bpy.types.Operator):
    bl_idname =i_0[47]
    bl_label =i_0[48]
    bl_description =i_0[49]
    tex_move_up = IntProperty(default = 0)
    tex_move_down = IntProperty(default = 0)
    def execute(self, context):
        try:
            ob = bpy.context.active_object
            mat = ob.active_material
            slots = mat.texture_slots
            index = mat.active_texture_index
            ts = slots[index]
            ctx = bpy.context.copy()
            ctx['texture_slot'] = ts
        except:
            pass
        moveValue = 0
        moveType = "NONE"
        if self.tex_move_up == 1:
            if index > 0:
                moveType = "UP"
                moveValue = -1
        if self.tex_move_down == 1:
            if index < 17:
                moveType = "DOWN"
                moveValue = 1
        if moveType != "NONE":
            safety = 0
            while safety < 16:
                safety += 1
                try:
                    tex = slots[mat.active_texture_index + moveValue]
                    if tex is None or tex.texture_coords != 'UV':
                        bpy.ops.texture.slot_move(ctx, type= moveType)
                    else:
                        bpy.ops.texture.slot_move(ctx, type= moveType)
                        self.tex_move_down = 0
                        self.tex_move_up = 0
                        safety = 17
                except:
                    pass
            fu11()
        return {'FINISHED'}
class cl15(bpy.types.Operator):
    bl_idname =i_0[50]
    bl_label =i_0[51]
    bl_description =i_0[52]
    tex_kill = IntProperty(name="tex_kill", default = 0)
    def execute(self, context):
        ob = bpy.context.active_object
        mat = ob.active_material
        ts = mat.texture_slots[self.tex_kill]
        texName = mat.texture_slots[self.tex_kill].name
        if ts.use_map_alpha == True:
            mat.use_transparency = False
        if ts.use_map_color_spec == True:
            mat.specular_color = (1, 1, 1)
            mat.specular_intensity = 0.5
        try: 
            if "specular" in ts.texture.image.name.lower():
                node = mat.node_tree.nodes['Image Texture zbSpecular']
                node = mat.node_tree.nodes['Math zbSpecular']
                node.inputs[1].default_value = 0
            if "glow" in ts.texture.image.name.lower():
                node = mat.node_tree.nodes['Image Texture zbGlow']
                node = mat.node_tree.nodes['Math zbGlow']
                node.inputs[1].default_value = 0
            if "alpha_mask" in ts.texture.image.name.lower():
                node = mat.node_tree.nodes['Image Texture zbAlpha_Mask']
                node.mute = True
            if "transparent" in ts.texture.image.name.lower():
                if len(mat.texture_slots.items()) == 1:
                    node = mat.node_tree.nodes['Image Texture zbColor']
                    node.mute = True
        except:
            pass
        try: 
            if self.tex_kill > -1:
                if ts:
                    if mat.texture_slots[self.tex_kill]:
                        imgDie = mat.texture_slots[self.tex_kill].texture.image
                        try:
                            bpy.data.images.remove(imgDie, do_unlink = True)
                        except:
                            if imgDie.users > 0:
                                imgDie.user_clear()
                            bpy.data.images.remove(imgDie)
                        ts.texture = None
                        mat.texture_slots.clear(self.tex_kill)
                if self.tex_kill == mat.active_texture_index:
                    x = 17
                    while x > -1:
                        if mat.texture_slots[x]:
                            bpy.ops.object.zb_set_active_layer(tex_index=x)
                            break
                        x -= 1
        except:
            pass
        fu0()
        if hasattr(mat.node_tree,'nodes'):
            nodes = mat.node_tree.nodes
            if 'Image Texture zbColor' in nodes:                
                colNode = nodes['Image Texture zbColor']
                if not colNode.image:
                    for slot in mat.texture_slots:
                        try:
                            if slot is not None:
                                if slot.texture:                                
                                    if slot.texture.type == 'IMAGE':
                                        if slot.texture.image:
                                            img = slot.texture.image
                                            if 'Color' in slot.texture.image.name:
                                                colNode.image = img
                                                break
                        except:
                            pass
        return {'FINISHED'}
class cl16(bpy.types.Operator):
    bl_idname =i_0[53]
    bl_label =i_0[54]
    bl_description =i_0[55]
    def execute(self,context):
        for img in bpy.data.images:
            img.reload()
        for area in bpy.context.screen.areas:
            if area.type == 'VIEW_3D':
                area.tag_redraw()
        return{'FINISHED'}
def fu13(self,context):
    scene = bpy.context.scene
    wm = bpy.context.window_manager
    scene.zbSaveToHardDrive = True
    wm.zbNewSavePath = True
    return
def zbSaveType(self,context):
    wm = bpy.context.window_manager
    wm.zbNewSavePath = True
    return
class cl17(bpy.types.Operator):
    bl_idname =i_0[56]
    bl_label =i_0[57]
    bl_description =i_0[58]
    save_only_active = bpy.props.BoolProperty()
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        mode = bpy.context.mode              
        userMsg = ''
        aType = 0
        try:
            aType = bpy.context.area.type
        except:
            pass  
        try:        
            if hasattr(scene,'active_object') is False:
                for obj in bpy.context.selected_objects:
                    scene.objects.active = obj
                    break
            ob = bpy.context.active_object
            mat = ob.active_material
            if mat:
                if scene.zbSaveToHardDrive:
                    if len(wm.zbSaveImagePath) < 3:
                        for ts in mat.texture_slots:
                            if ts is not None:
                                try:
                                    if ts.texture_coords == 'UV':
                                        if ts.texture.type == 'IMAGE':
                                            try:
                                                imgPath = bpy.path.abspath(ts.texture.image.filepath)
                                                if "\\..\\" not in imgPath:
                                                    imgDir = os.path.dirname(imgPath)
                                                    if len(imgDir) > 3:
                                                        wm.zbSaveImagePath = imgDir + "\\"
                                                        break
                                                    break
                                            except:
                                                pass
                                except:
                                    pass
                        if len(wm.zbSaveImagePath) < 3:
                            for ob in bpy.data.objects:
                                if ob.active_material:
                                    for ts in ob.active_material.texture_slots:
                                        try:
                                            if ts.texture_coords == 'UV':
                                                if ts.texture.image:
                                                    imgPath = bpy.path.abspath(ts.texture.image.filepath)
                                                    if len(imgPath) > 3:
                                                        if "\\..\\" not in imgPath:
                                                            imgDir = os.path.dirname(imgPath)
                                                            if len(imgDir) > 3:
                                                                wm.zbSaveImagePath = imgDir + "\\"
                                                                break
                                        except:
                                            pass
                    if len(wm.zbSaveImagePath) < 3:
                        userMsg = ("You must select a folder before saving to hard drive")
                    else:
                        for ts in mat.texture_slots:
                            if ts is not None: 
                                try:
                                    ts.texture.image
                                    texName = ts.texture.name
                                    imgName = ts.texture.image.name
                                    types = ['Color', 'Bump', 'Specular', 'Glow',
                                            'Transparent', 'Alpha_Mask']
                                    for type in types:         
                                        if type.lower() in imgName.lower():
                                            if type.lower() in texName.lower():
                                                newName = texName
                                            else:
                                                newName = texName + type                                                                                                                    
                                    ts.texture.image.name = newName                                    
                                except:
                                    pass                            
                        newSaveState = wm.zbNewSavePath
                        zbsip = wm.zbSaveImagePath
                        wm.zbSaveImagePath = bpy.path.abspath(zbsip)
                        wm.zbNewSavePath = newSaveState
                        aType = bpy.context.area.type
                        bpy.context.area.type = 'IMAGE_EDITOR'
                        i = 0
                        for slot in mat.texture_paint_slots:
                            newSaveLocation = True
                            img = mat.texture_paint_images[i]
                            mat.paint_active_slot = i
                            if "\\..\\" in img.filepath:
                                img.filepath_raw = ""
                            if len(img.filepath) > 3:
                                if wm.zbNewSavePath == False:
                                    print("Saving image at it's previous save location")
                                    newSaveLocation = False
                                    bpy.ops.image.save()
                            if self.save_only_active:
                                if not img.packed_file:
                                    newSaveLocation = False
                            if newSaveLocation:
                                print('Saving image using selected folder location')
                                override = bpy.context.copy()
                                override['edit_image'] = img
                                bpy.ops.image.pack(override, as_png = True)
                                ff = wm.zbSaveType
                                ff = ff.replace(".","")
                                if ff == 'TGA':
                                    ff = 'TARGA'
                                img.file_format = ff
                                path = bpy.path.abspath(wm.zbSaveImagePath)
                                imgPath = path + img.name + wm.zbSaveType
                                bpy.ops.image.save_as(filepath = imgPath)
                                if img.packed_file:
                                    bpy.ops.image.unpack(method = 'WRITE_ORIGINAL')
                                    img.filepath_raw = bpy.path.abspath(imgPath)
                                try: 
                                    blendFilePath = bpy.data.filepath
                                    blendFileDir = os.path.dirname(blendFilePath)
                                    imgToX = os.path.join(blendFileDir, img.name)
                                    if os.path.exists(imgToX):
                                        os.remove(imgToX)
                                except:
                                    pass                                
                            i += 1 
                    if aType:
                        bpy.context.area.type = aType
                else:
                    if self.save_only_active:
                        layersAmount = 0
                        for ts in mat.texture_slots:
                            if ts is not None:
                                try:
                                    if ts.texture.type == 'IMAGE':
                                        if ts.texture_coords  == 'UV':
                                            image = ts.texture.image
                                            override = bpy.context.copy()
                                            override['edit_image'] = image
                                            bpy.ops.image.pack(override, as_png = True)
                                            layersAmount += 1
                                except:
                                    pass
                        if mode != 'PAINT_TEXTURE':
                            userMsg = "Paint layers saved."
                    else:
                        layersAmount = 0
                        for ob in bpy.data.objects:
                            mat = ob.active_material
                            if mat:
                                for ts in mat.texture_slots:
                                    if ts is not None:
                                        try:
                                            if ts.texture.type == 'IMAGE':
                                                if ts.texture_coords  == 'UV':
                                                    image = ts.texture.image
                                                    override = bpy.context.copy()
                                                    override['edit_image'] = image
                                                    bpy.ops.image.pack(override, as_png = True)
                                                    layersAmount += 1
                                        except:
                                            pass                                        
                        userMsg = "All paint layers saved."
        except:
            userMsg = "Had trouble saving all images."
        if userMsg:
            self.report({'INFO'}, userMsg)
        if wm.zbNewSavePath:
            wm.zbNewSavePath = False
        return {'FINISHED'}
class cl18(bpy.types.Operator):
    bl_idname =i_0[59]
    bl_label =i_0[60]
    bl_description =i_0[61]
    action = bpy.props.StringProperty(default='START')
    @classmethod
    def poll(cls, context):
        return bpy.context.active_object.type == 'MESH'
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        renEng = scene.render.engine
        ob = bpy.context.active_object
        mat = ob.active_material
        proxy = 0
        for obj in bpy.data.objects:
            if '_zb_proxy' in obj.name:
                proxy = obj
                mainObName = proxy.name.strip('_zb_proxy')
                mainOb = bpy.data.objects[mainObName]
        if not proxy:
            mainOb = ob            
        if self.action == 'START':
            bpy.ops.object.zb_save_layers(save_only_active = True)
            ob.data.tag = False
            if renEng == 'CYCLES':
                ob.data.tag = True
            scene.zbGoCycles = False
            fu18()
            brush = bpy.context.tool_settings.image_paint.brush
            img = brush.texture.image
            newName = ob.name[:4] + 'BrushColor'
            bpy.ops.object.zb_paint_color()
            mat.active_texture.name = newName
            mat.active_texture.image.name = newName
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.duplicate()
            proxy = ob.name[:4] + '_zb_proxy'
            ob = bpy.context.active_object
            ob.name = proxy
            ob.data.name = proxy
            ob = bpy.context.active_object
            bpy.ops.object.material_slot_remove()
            newMat = bpy.data.materials.new(name=proxy)
            ob.active_material = newMat
            mat = ob.active_material
            newTex = bpy.data.textures.new(name=proxy, type='IMAGE')
            mat.active_texture = newTex
            newTex.image = img
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.uv.cylinder_project()
            for uv_face in ob.data.uv_textures.active.data:
                uv_face.image = img
            mat.texture_slots[proxy].scale[0] = 5
            mat.texture_slots[proxy].scale[1] = 1
            mainOb.hide = True
            wm.showBrushLayerOptions = True
            bpy.ops.object.mode_set(mode='OBJECT')
        if self.action == 'CANCEL': 
            if mainOb.data.tag:
                print('data tag is true')
                scene.zbGoCycles = True
            wm.showBrushLayerOptions = False
            scene.objects.active = mainOb
            mainOb.select = True
            mainOb.hide = False
            mainOb.select = False
            scene.objects.active = proxy
            for ts in proxy.active_material.texture_slots:
                if hasattr(ts,'texture'):
                    if ts.texture:
                        ts.texture = None   
            for ms in proxy.material_slots:
                if hasattr(ms,'material'):
                    if ms.material:
                        ms.material = None  
            bpy.ops.object.delete()
            mainOb.select = True
            scene.objects.active = mainOb
            n = 0 
            for ts in mainOb.active_material.texture_slots:
                try:
                    if 'BrushLayer' in ts.texture.name:
                        break
                except:
                    pass
                n += 1
            if n > 17:
                n = 17
            bpy.ops.object.zb_delete_texture(tex_kill=n)
            bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
        if self.action == 'FLIP':
            for obj in bpy.data.objects:
                if '_zb_proxy' in obj.name:
                    ob = obj
                    scene.objects.active = ob
                    break
            brush = bpy.context.tool_settings.image_paint.brush
            img = brush.texture.image
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.uv.cylinder_project()
            for uv_face in ob.data.uv_textures.active.data:
                uv_face.image = img
            bpy.ops.object.mode_set(mode='OBJECT')
            self.flip = False
        if self.action == 'FINISH':                
            wm.showBrushLayerOptions = False
            for ob in bpy.data.objects:
                if '_zb_proxy' in ob.name:
                    proxy = ob
                    ob.hide = False
                    ob.hide_render = False
                    ob.select = True
                else:
                    ob.select = False
            mainOb.hide = False
            mainOb.hide_render = False
            mainOb_location = mainOb.location.xyz
            mainOb_scale = mainOb.scale.xyz
            mainOb_rotX = mainOb.rotation_euler[0]
            mainOb_rotY = mainOb.rotation_euler[1]
            mainOb_rotZ = mainOb.rotation_euler[2]
            mainOb.location = proxy.location
            mainOb.rotation_euler = proxy.rotation_euler
            mainOb.scale = proxy.scale
            scene.objects.active = mainOb
            mainOb.select = True
            mainOb.hide = False
            scene.render.bake_type = 'TEXTURE'
            scene.render.use_bake_selected_to_active = True
            scene.render.bake_distance = 1
            mat = mainOb.active_material
            activeTex = mat.active_texture
            mat.active_texture = None
            bpy.ops.object.bake_image()
            mat.active_texture = activeTex
            img = activeTex.image
            override = bpy.context.copy()
            override['edit_image'] = img
            bpy.ops.image.pack(override, as_png = True)
            mainOb.select = False
            scene.objects.active = proxy
            for ts in proxy.active_material.texture_slots:
                if hasattr(ts,'texture'):
                    if ts.texture:
                        ts.texture = None   
            for ms in proxy.material_slots:
                if hasattr(ms,'material'):
                    if ms.material:
                        ms.material = None             
            bpy.ops.object.delete()
            mainOb.select = True
            scene.objects.active = mainOb
            mat = mainOb.active_material
            tex = mat.active_texture
            ts = mat.texture_slots[tex.name]
            ts.use_map_normal = True
            ts.normal_factor = 0
            mainOb.location = mainOb_location.xyz
            mainOb.scale = mainOb_scale.xyz
            mainOb.rotation_euler[0] = mainOb_rotX
            mainOb.rotation_euler[1] = mainOb_rotY
            mainOb.rotation_euler[2] = mainOb_rotZ
            if mainOb.data.tag:
                scene.zbGoCycles = True
                mainOb.data.tag = False
            bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
            fu0()
        return{'FINISHED'}
class cl19(bpy.types.Operator):
    bl_idname =i_0[62]
    bl_label =i_0[63]
    bl_description =i_0[64]
    def execute(self,context):
        scene = bpy.context.scene
        mode = bpy.context.mode
        re = scene.render.engine
        wm = bpy.context.window_manager
        ob = bpy.context.active_object
        mat = ob.active_material
        selected = bpy.context.selected_objects
        bpy.ops.object.zb_save_layers(save_only_active=True)
        bpy.ops.object.mode_set(mode='OBJECT')
        if re == 'CYCLES':
            scene.zbGoCycles = False
        newName = ob.name[:4] + 'Normal'        
        img = bpy.data.images.new(name= newName, width= scene.zbImgSize,
        height = scene.zbImgSizeH)        
        for obj in bpy.data.objects:
            if hasattr(obj,'active_material'):
                if obj.active_material == ob.active_material:
                    obj.select = True
                    if obj.data.uv_textures:
                        for uv_face in ob.data.uv_textures.active.data:
                            uv_face.image = img
                else:
                    obj.select = False
        override = bpy.context.copy()
        override['edit_image'] = img
        bpy.ops.image.pack(override, as_png = True)
        scene.render.use_bake_multires = False
        scene.render.bake_type = 'NORMALS'
        bpy.ops.object.bake_image()
        bpy.ops.object.zb_paint_normal()
        for i in range(16):
            bpy.ops.object.zb_move_texture(tex_move_up=1)
        mat = ob.active_material
        tex = mat.active_texture
        tex.image = img
        tex.use_normal_map = True
        mat.texture_slots[tex.name].use_map_color_diffuse = False
        mat.texture_slots[tex.name].normal_factor = 5
        fu21(mat)
        try: 
            for slot in mat.texture_slots:
                try: 
                    if slot.use_map_normal:
                        if slot.texture.use_normal_map == False:
                            if slot.use_map_color_diffuse == False:
                                slot.use = False
                except:
                    pass
                try: 
                    if slot.use_map_color_diffuse:
                        if slot.use_map_normal:
                            slot.normal_factor = 0
                except:
                    pass
                try: 
                    if slot.texture.use_normal_map:
                        if slot.texture.name != mat.active_texture.name:
                            slot.use = False
                except:
                    pass
        except:
            pass
        if re == 'CYCLES':
            scene.zbGoCycles = True
        fu1(mode)
        fu0()
        return{'FINISHED'}
class zbBake(bpy.types.Operator):
    bl_label =i_0[65]
    bl_idname =i_0[66]
    bl_description =i_0[67]
    bake_type = bpy.props.StringProperty(default='')
    def execute(self,context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        mode = bpy.context.mode        
        renEng = scene.render.engine
        bake_type = self.bake_type   
        bt = bake_type
        mat = 0
        fu19() 
        abort, mSize, userMessage = fu20(bake_type)
        selected = bpy.context.selected_objects            
        ob = bpy.context.active_object     
        mainOb = 0                
        origActive = ob.name
        activeTex = 0
        if abort is False:
            multiresNormalBake = False
            if 'NORMAL' in bt or 'DISPLACEMENT' in bt or 'DERIVATIVE' in bt:                              
                for obj in selected:
                    for mod in obj.modifiers:
                        if mod.type == 'MULTIRES':
                            multiresNormalBake = True
                            break
                    if multiresNormalBake:
                        break
                if bt == 'MERGE_NORMALS':
                    multiresNormalBake = True
            else:
                multiresNormalBake = True                     
            regularBake = True
            origSelected = 0
            orig_zbBakeSingle_state = scene.zbBakeSingle
            if 'Shared-UVMap' in ob.data.uv_textures:
                scene.zbBakeSingle = True
                sharedMat = ob.active_material
                if ob.active_material:
                    for obj in bpy.data.objects:
                        if obj.active_material == ob.active_material:
                            print('    ',obj.name)
                            obj.select = True
                        else:
                            obj.select = False
                selected = bpy.context.selected_objects
            else:
                if len(selected) == 1:
                    scene.zbBakeSingle = False
            if scene.zbBakeSingle:                  
                if ob.data.uv_textures:
                    regularBake = False  
                    ob = fu16(selected,bt,mSize)
                else:    
                    if scene.zbUseLightMap:
                        bpy.ops.uv.lightmap_pack(PREF_CONTEXT='ALL_OBJECTS',
                        PREF_PACK_IN_ONE=True,PREF_NEW_UVLAYER=True,
                        PREF_MARGIN_DIV = .3)
                    else:
                        bpy.ops.uv.smart_project(island_margin = 0.03, 
                        angle_limit = 45, stretch_to_bounds = False)                        
                    for obj in selected:
                        obj.data.uv_textures.active.name = 'Shared-UVMap'
                if regularBake:     
                    print('Used Regular Bake')
                    bpy.ops.object.duplicate()
                    origSelected = selected
                    for obj in origSelected:
                        obj.hide_render = True
                        obj.hide = True
                    if 'NORM' not in bt and 'DISP' not in bt and 'DERIV' not in bt:                                       
                        for obj in bpy.context.selected_objects:
                            scene.objects.active = obj
                            for mod in obj.modifiers:
                                try:
                                    bpy.ops.object.modifier_apply(apply_as='DATA',
                                    modifier = mod.name)
                                except:
                                    pass
                    bpy.ops.object.join()
                    selected = bpy.context.selected_objects
                    ob = bpy.context.active_object
            if multiresNormalBake:      
                if regularBake:                                    
                    for ob in selected: 
                        bakeAllProceed = True
                        if scene.zbBakeSelectedToActive:
                            if ob != bpy.context.active_object:
                                bakeAllProceed = False
                        if bakeAllProceed:         
                            layerTypeChoice = 'Color'
                            if 'SPEC' in bt: 
                                layerTypeChoice = 'Specular'                        
                            adaptiveState = ob.cycles.use_adaptive_subdivision
                            ob.cycles.use_adaptive_subdivision = False
                            scene.objects.active = ob  
                            for obj in bpy.data.objects:
                                if obj != bpy.context.active_object:
                                    obj.select = False
                                else:
                                    obj.select = True                                
                            if 'NORM' in bt or 'DISP' in bt or 'DERIV' in bt:   
                                if bt == 'MERGE_NORMALS':
                                    bpy.ops.object.zb_bump_to_normal()
                                else:
                                    quit = True
                                    for mod in ob.modifiers:
                                        if mod.type == 'MULTIRES':
                                            quit = False
                                            bpy.ops.object.zb_bake_normal()      
                                            break
                                    if quit:
                                        userMessage = 'Selected objects must have multires modifiers for this kind of baking.'
                                        print(userMessage)
                            else:                                                   
                                img = 0
                                adjustNonZB = False     
                                addLayer = True 
                                multiMatPlusUV = False
                                selectedToActive = False
                                if len(ob.data.materials) > 1:   
                                    selectedToActive = True 
                                    if ob.data.uv_textures:
                                        uvMap = ob.data.uv_textures.active
                                        if uvMap.name != 'Shared-UVMap':
                                            multiMatPlusUV = True
                                    else:
                                        fu10(ob)
                                    mainOb = bpy.data.objects[ob.name]                                                      
                                    bpy.ops.object.duplicate()                            
                                    ob = bpy.context.active_object
                                    for m in ob.data.materials:
                                        bpy.ops.object.material_slot_remove()
                                    mainOb.select = True                            
                                    scene.render.use_bake_selected_to_active = True
                                if ob.active_material: 
                                    mat = ob.active_material                               
                                    makeMatCopy = False
                                    if hasattr(mat.node_tree,'nodes'):
                                        nodes = mat.node_tree.nodes
                                        if 'Image Texture zbColor' not in nodes:
                                            makeMatCopy = True
                                    else:
                                        makeMatCopy = True                                                                                                                              
                                    if mat.users > 1:
                                        makeMatCopy = True                                                            
                                    if makeMatCopy:
                                        adjustNonZB = True  
                                        mat.use_fake_user = True
                                        matCopy = mat.copy()
                                        ob.active_material = matCopy   
                                        matCopy.name = ob.name.strip() + ' Baked'                             
                                        mat = matCopy
                                        if renEng == 'CYCLES':
                                            mat.name = 'zbConduit'
                                            addLayer = False
                                            fu10(ob)
                                            w = round(scene.zbImgSize)
                                            h = round(scene.zbImgSizeH)
                                            layerName = ob.name[:4] + 'Color' + bt
                                            img = bpy.data.images.new(layerName, scene.zbImgSize, 
                                            scene.zbImgSizeH, alpha= True)
                                            img.pixels[:] = (0, 0, 0, 0) * w * h
                                            override = bpy.context.copy()
                                            override['edit_image'] = img
                                            bpy.ops.image.pack(override, as_png = True)
                                            for uv_face in ob.data.uv_textures.active.data:
                                                uv_face.image = img
                                            if mat.use_nodes is False:
                                                mat.use_nodes = True
                                            nodes = mat.node_tree.nodes
                                            node = nodes.new(type = 'ShaderNodeTexImage')
                                            node.label = 'zbConduit'
                                            node.name = node.label
                                            node.image = img
                                            node.select = True
                                            nodes.active = node
                                imgTexNode = 0
                                if addLayer:                                 
                                    if multiMatPlusUV:
                                        proceed = False 
                                        for uv_face in ob.data.uv_textures.active.data:
                                            if uv_face.image:
                                                proceed = True
                                                break
                                        if proceed:    
                                            for uv in ob.data.uv_textures:
                                                bpy.ops.mesh.uv_texture_remove()
                                    mat,tex,activeTex,newTexName,imgTexNode,zbConduit_AL = fu15(layerTypeChoice,ob,renEng,bt)
                                if scene.render.use_bake_multires:
                                    if ob.modifiers:
                                        useMulti = False
                                        for mod in ob.modifiers:
                                            if mod.type == 'MULTIRES':
                                                if mod.levels > 0:
                                                    useMulti = True
                                                else:
                                                    bpy.ops.object.modifier_remove(modifier=mod.name)           
                                        if useMulti is False:
                                            scene.render.use_bake_multires = False
                                    else:
                                        scene.render.use_bake_multires = False
                                bk = scene.render
                                cbk = bk.bake
                                if scene.zbUserBakeSettings:                                    
                                    cageExtrude = cbk.cage_extrusion
                                    mSize = cbk.margin  
                                    useClear = False                                                           
                                else:                                                                   
                                    cageExtrude = .001
                                    useClear = False
                                if scene.zbBakeSelectedToActive:
                                    selectedToActive = True 
                                    bk.use_bake_selected_to_active = True                                                                                                                           
                                    for obj in selected:
                                        obj.select = True 
                                    if scene.zbUserBakeSettings is False:
                                        cageExtrude = 1                               
                                else: 
                                    bk.use_bake_selected_to_active = False                        
                                if renEng == 'CYCLES': 
                                    bpy.ops.object.bake(type=bake_type, margin=mSize,
                                    use_selected_to_active = selectedToActive, use_clear = useClear,
                                    cage_extrusion = cageExtrude)
                                else:    
                                    bpy.ops.object.bake_image()
                                if addLayer:
                                    fu15Finish(mat,imgTexNode,activeTex,newTexName,bt,zbConduit_AL)                                                          
                                else:
                                    if renEng == 'CYCLES':
                                        if img:
                                            ob.active_material = None
                                            bpy.ops.object.zb_paint_color()
                                            mat = ob.active_material                                    
                                            mat.name = mat.name.strip() + ' Baked'
                                            tex = mat.active_texture
                                            tex.image = img
                                            tex.name = img.name 
                                            imgTexNode = mat.node_tree.nodes['Image Texture zbColor']
                                            imgTexNode.image = img
                                if adjustNonZB:
                                    i = 0 
                                    for ts in mat.texture_slots:
                                        if hasattr(ts,'texture'):
                                            if hasattr(ts.texture,'type'):
                                                if ts.texture.type != 'IMAGE':
                                                    tex = ts.texture
                                                    mat.texture_slots[i].texture = None
                                        i+=1
                                if activeTex:                     
                                    if bake_type == 'SHADOW' or bake_type == 'AO':
                                        slot = mat.texture_slots[activeTex]
                                        slot.blend_type = 'MULTIPLY'
                                        slot.use_map_normal = True
                                        slot.normal_factor = 0
                                if selectedToActive:
                                    bpy.ops.object.mode_set(mode='OBJECT')
                                    matName = mat.name.split('.')[0]
                                    matName = matName + ' Baked'
                                    mat.name = matName
                                    if mainOb:
                                        scene.objects.active = mainOb
                                        for m in mainOb.data.materials:
                                            bpy.ops.object.material_slot_remove()
                                        mainOb.active_material = mat
                                        mainOb.select = False
                                        scene.objects.active = ob
                                        bpy.ops.object.delete()
                                        scene.objects.active = mainOb
                                        mainOb.select = True
                                        ob = mainOb
                                    if multiMatPlusUV:
                                        proceed = False 
                                        for uv_face in ob.data.uv_textures.active.data:
                                            if uv_face.image:
                                                proceed = True
                                                break
                                        if proceed:    
                                            for uv in ob.data.uv_textures:
                                                bpy.ops.mesh.uv_texture_remove()
                                            fu10(ob)
                                bpy.ops.object.mode_set(mode='OBJECT')                        
                                ob.cycles.use_adaptive_subdivision = adaptiveState
                                if selected[-1] != ob:   
                                    print('')  
                                if scene.zbBakeSelectedToActive:
                                    scene.zbBakeSelectedToActive = False
                                    break
            else:                
                if len(selected) == 2:
                    scene.render.engine = 'BLENDER_RENDER'                 
                    if 'NORMAL' in bake_type:
                        scene.render.bake_type = 'NORMALS'
                    if 'DISPLACEMENT' in bake_type:
                        scene.render.bake_type = 'DISPLACEMENT'
                    if 'DERIVATIVE' in bake_type:
                        scene.render.bake_type = 'DERIVATIVE'
                    scene.render.use_bake_clear = False
                    scene.render.use_bake_multires = False
                    scene.render.use_bake_selected_to_active = True
                    scene.render.bake_distance = 1.5
                    if bt != 'DISPLACEMENT' and bt != 'DERIVATIVE':
                        if not ob.active_material:
                            bpy.ops.object.zb_paint_color()                      
                    bpy.ops.object.zb_paint_normal()        
                    mat = ob.active_material
                    tex = mat.active_texture  
                    ts = mat.texture_slots[tex.name]                    
                    if 'DISPLACEMENT' not in bt:
                        for i in range(16):
                            bpy.ops.object.zb_move_texture(tex_move_up=1)
                        tex.use_normal_map = True
                        ts.normal_factor = 5
                    if bt == 'DERIVATIVE':
                        ts.normal_factor = .4
                    ts.use_map_color_diffuse = False          
                    fu18() 
                    activeTex = mat.active_texture_index
                    mat.use_textures[activeTex] = False
                    bpy.ops.object.mode_set(mode='OBJECT')
                    bpy.ops.object.bake_image()                     
                    mat.use_textures[activeTex] = True
                    if 'NORMAL' in bt:
                        fu21(mat)
                    ts.use_map_color_diffuse = False
                    ts.texture.use_normal_map = True
                    ts.normal_factor = 5    
                else:
                    bpy.ops.object.zb_message('INVOKE_DEFAULT',
                    message = 'TRADITIONAL_NORMALS_BAKE')
            if origSelected:
                for obj in origSelected:
                    obj.hide_render = False
                    obj.hide = False
                    obj.select = True
                    scene.objects.active = obj
                    for m in obj.data.materials:
                        bpy.ops.object.material_slot_remove()                    
                    if mat:
                        obj.active_material = mat
                    else:
                        obj.active_material = ob.active_material
                    obj.select = False
                ob.select = True
                scene.objects.active = ob
                bpy.ops.object.delete()
                for obj in origSelected:
                    obj.select = True
                    scene.objects.active = obj
            if bt == 'TEXTURE':
                mat = bpy.context.active_object.active_material
                for ts in mat.texture_slots:
                    if hasattr(ts,'texture'):
                        try:
                            tex = ts.texture
                            if 'merged' not in tex.name.lower():
                                if 'color' in tex.image.name.lower():
                                    mat.texture_slots[tex.name].use = False                        
                        except:
                            pass
            for obj in bpy.context.selected_objects:            
                obj.cycles.use_adaptive_subdivision = False
        bpy.ops.object.zb_save_layers(save_only_active=True)
        scene.render.engine = renEng        
        for ob in selected:
            ob.select = True
        scene.zbBakeSingle = orig_zbBakeSingle_state
        scene.objects.active = bpy.data.objects[origActive]
        if renEng == 'CYCLES':
            scene.zbGoCycles = True  
        else:
            scene.zbGoCycles = False 
        if renEng == 'CYCLES':
            if scene.zbQuickLights:
                for ob in bpy.data.objects:
                    if 'zbCyclesLight' in ob.name:
                        ob.hide = True
        fu1(mode)                                         
        if userMessage:
            self.report({'INFO'}, userMessage)                
        return{'FINISHED'}
class cl20(bpy.types.Menu):
    bl_label =i_0[68]
    bl_idname =i_0[69]
    description = "Select a bake type to bake"    
    def draw(self, context):
        scene = bpy.context.scene
        renEng = scene.render.engine
        brBakeTypes = ['FULL', 'AO', 'SHADOW', 'NORMALS', 'TEXTURE', 
        'DISPLACEMENT', 'DERIVATIVE', 'VERTEX_COLORS', 'EMIT', 'ALPHA',         
        'MIRROR_INTENSITY', 'MIRROR_COLOR', 'SPEC_INTENSITY', 'SPEC_COLOR']        
        cyBakeTypes = ['COMBINED', 'AO', 'SHADOW', 'NORMAL', 'UV', 'EMIT', 
        'ENVIRONMENT', 'DIFFUSE', 'GLOSSY', 'TRANSMISSION', 'SUBSURFACE']
        bakeTypes = []
        bakeTypes.append(brBakeTypes)
        bakeTypes.append(cyBakeTypes)
        layout = self.layout
        bt = bakeTypes[0]
        if bpy.context.active_object:
            if renEng == 'CYCLES':
                bt = bakeTypes[1]                    
            for type in bt:
                bType = type.replace('_',' ').title()     
                if len(bType) < 3:
                    bType = bType.upper()     
                if bType == 'AO':
                    bType = 'Ambient Occlusion'     
                if bType == 'Full':
                    bType = 'Full Material Bake'
                if bType == 'Combined':
                    bType = 'Full Bake (combined)'
                if bType == 'Texture':
                    bType = 'Textures (merge)'
                layout.operator('object.zb_message',text=bType).message = type
        else:
            layout.label('There is no active object to bake')
def fu14():
    scene = bpy.context.scene
    selected = bpy.context.selected_objects
    origActive = bpy.context.active_object.name
    scene.render.use_bake_multires = False   
    for obj in selected:
        for mod in obj.modifiers:
            if mod.type == 'MULTIRES':
                scene.render.use_bake_multires = True
                break 
    if scene.render.use_bake_multires:
        for obj in selected:
            scene.objects.active = obj
            needsMultires = True
            if obj.modifiers:
                for mod in obj.modifiers:
                    if mod.type == 'MULTIRES':
                        needsMultires = False
                        break
            if needsMultires:
                mod = obj.modifiers.new(name='Multires',type='MULTIRES')
                bpy.ops.object.multires_subdivide(modifier=mod.name)
                txt1 = 'to make compatible with other baked objects using multires.'
                for mod in obj.modifiers:
                    if mod.type == 'MULTIRES':
                        mod.show_expanded = False
                        break    
            if obj == selected[-1]:
                print('')
    scene.objects.active = bpy.data.objects[origActive]
def fu15(layerTypeChoice,ob,renEng,bt):
    texLayerAdder(layerType=layerTypeChoice, texCol = 1, 
    texOpas = 0, alphaChoice = True, normalChoice = True)    
    mat = ob.active_material
    tex = mat.active_texture
    newTexName = bt
    if newTexName == 'TEXTURE':
        newTexName = 'MERGED'
    newTexName = tex.name.split('.')[0] + ' ' + newTexName
    tex.name = newTexName
    tex.image.name = newTexName                            
    activeTex = mat.active_texture_index        
    mat.use_textures[activeTex] = False  
    zbConduit_AL = 0
    imgTexNode = 0
    if renEng == 'CYCLES':
        nodes = mat.node_tree.nodes
        imgTexNode = nodes['Image Texture zbColor']                                
        imgTexNode.mute = True
        for node in nodes:
            node.select = False
        zbConduit_AL = nodes.new(type = 'ShaderNodeTexImage')
        zbConduit_AL.label = 'zbConduit'
        zbConduit_AL.name = zbConduit_AL.label
        zbConduit_AL.image = tex.image
        zbConduit_AL.select = True
        nodes.active = zbConduit_AL   
    return mat,tex,activeTex,newTexName,imgTexNode,zbConduit_AL
def fu15Finish(mat,imgTexNode,activeTex,newTexName,bt,zbConduit_AL):
    mat.use_textures[activeTex] = True                            
    if imgTexNode:
        imgTexNode.mute = False
        nodes = mat.node_tree.nodes
        nodes.remove(zbConduit_AL)
    if 'SPEC' in bt:
        ts = mat.texture_slots[mat.active_texture_index]
        ts.use_map_color_diffuse = False
        ts.use_map_normal = False
        ts.use_map_color_spec = True
    if 'MERGED' in newTexName:
        i = 0 
        for ts in mat.texture_slots:
            if hasattr(ts,'texture'):
                if ts.texture is not None:
                    if ts.texture.type == 'IMAGE':
                        if ts.texture != mat.active_texture:
                            if ts.texture.image:
                                if 'Color' in ts.texture.image.name:
                                    mat.texture_slots[i].use = False
            i+=1   
def fu16(selected,bt,mSize):
    bpy.ops.object.mode_set(mode='OBJECT')
    scene = bpy.context.scene
    renEng = scene.render.engine
    ob = bpy.context.active_object
    origMat = ob.active_material
    origSelected = selected
    origActive = ob.name
    firstMultiUVBake = False
    if 'Shared-UVMap' not in ob.data.uv_textures:
        firstMultiUVBake = True      
    useNormal = False   
    if 'NORM' in bt or 'DISP' in bt or 'DERIV' in bt:  
        useNormal = True                               
    bpy.ops.object.duplicate() 
    fu17(useNormal)                                           
    artObject = bpy.context.active_object
    artObject.name = 'Bake Source Object'
    artObject.select = False
    needsUnwrap = True
    for obj in origSelected:
        obj.select = True
        scene.objects.active = obj
        for mat in obj.data.materials:
            bpy.ops.object.material_slot_remove()        
        for uvMap in obj.data.uv_textures:
            if 'Shared-UVMap' in uvMap.name:
                needsUnwrap = False
            else:
                bpy.ops.mesh.uv_texture_remove()                
    scene.objects.active = bpy.data.objects[origActive]
    if needsUnwrap:
        if scene.zbUseLightMap:
            bpy.ops.uv.lightmap_pack(PREF_CONTEXT='ALL_OBJECTS',
            PREF_PACK_IN_ONE=True,PREF_NEW_UVLAYER=True,
            PREF_MARGIN_DIV = .3)
        else:
            bpy.ops.uv.smart_project(island_margin = 0.03, 
            angle_limit = 45, stretch_to_bounds = False)                        
        for obj in bpy.context.selected_objects:
            obj.data.uv_textures.active.name = 'Shared-UVMap'    
    if useNormal:
        scene.objects.active = artObject
    else:
        bpy.ops.object.duplicate()
        fu17(useNormal)              
        bakeProxy = bpy.context.active_object    
    ob = bpy.context.active_object
    for obj in origSelected:
        obj.hide = True
        obj.hide_render = True    
    artObject.select = True
    if useNormal:
        scene.render.engine = 'BLENDER_RENDER'   
        if bt == 'MERGE_NORMALS':
            bpy.ops.object.zb_bump_to_normal()
        else:         
            bpy.ops.object.zb_bake_normal()            
    else:
        layerTypeChoice = 'Color'
        if 'SPEC' in bt: 
            layerTypeChoice = 'Specular'  
        mat,tex,activeTex,newTexName,imgTexNode,zbConduit_AL = fu15(layerTypeChoice,ob,renEng,bt)          
        if renEng == 'CYCLES': 
            bpy.ops.object.bake(type=bt, margin=mSize,
            use_selected_to_active = True, use_clear = False,
            cage_extrusion = .001)
        else:        
            scene.render.use_bake_selected_to_active = True
            scene.render.use_bake_multires = False
            for obj in bpy.context.selected_objects:
                for mod in obj.modifiers:
                    if mod.type == 'MULTIRES':
                        scene.render.use_bake_multires = True
                        break
                if scene.render.use_bake_multires:
                    break                        
            bpy.ops.object.bake_image()
        fu15Finish(mat,imgTexNode,activeTex,newTexName,bt,zbConduit_AL)
    if firstMultiUVBake: 
        print('Adjusting Materials For First (Bake To Single)')   
        finalMat = bakeProxy.active_material
        finalMat.name = ob.name.split('.')[0] + ' Baked'
        for obj in origSelected:
            obj.active_material = finalMat
            obj.hide = False
            obj.hide_render = False
            obj.select = False    
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.delete()
        for obj in origSelected:
            scene.objects.active = obj
            obj.select = True
    else:
        print('Adjusting Materials For (Bake To Single)')
        for obj in origSelected:
            scene.objects.active = obj
            obj.select = False
            obj.hide = False
            obj.hide_render = False
            obj.active_material = origMat
        scene.objects.active = bpy.data.objects[origActive]
        if useNormal: 
            bpMat = artObject.active_material
            if 'DISP' not in bt and 'DERIV' not in bt:
                texIndex = mat.active_texture_index
                activeSlot = mat.texture_slots[texIndex]
                activeSlot.use_map_color_diffuse = False
                activeSlot.use_map_normal = True
                activeSlot.normal_factor = 5  
                fu21(mat)
        else:
            bpMat = bakeProxy.active_material                
            i=0 
            ob = bpy.context.active_object
            for ts in ob.active_material.texture_slots:
                if hasattr(ts,'texture') is False:
                    ob.active_material.active_texture_index = i
                    break
                i+=1
            mat = ob.active_material    
            mat.active_texture = bpMat.active_texture
            tex = ob.active_material.active_texture
            img = tex.image
        if 'SHADOW' in bt or 'AO' in bt:
            slot = mat.texture_slots[tex.name]
            slot.blend_type = 'MULTIPLY'
            slot.use_map_normal = True
            slot.normal_factor = 0
        for ts in mat.texture_slots:
            if useNormal:
                bpy.ops.object.zb_move_texture(tex_move_up=1)
            else:
                bpy.ops.object.zb_move_texture(tex_move_down=1)
        bpy.ops.object.zb_set_active_layer(tex_index=mat.active_texture_index)
        if useNormal is False:    
            bakeProxy.select = True
            bpMat.user_clear()
        artObject.select = True        
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.delete()
        for obj in origSelected:
            obj.select = True    
        scene.objects.active = bpy.data.objects[origActive]
def fu17(useNormal):
    scene = bpy.context.scene
    selected = bpy.context.selected_objects
    origActive = bpy.context.active_object.name                                 
    if useNormal: 
        for obj in selected:
            scene.objects.active = obj
            needMulti = True
            for mod in obj.modifiers:
                if mod.type == 'MULTIRES':
                    needMulti = False
                else:
                    try:
                        bpy.ops.object.modifier_apply(apply_as='DATA',
                        modifier = mod.name)
                    except:
                        pass
            if needMulti:
                bpy.ops.object.modifier_add(type='MULTIRES')        
    else:
        for obj in selected:
            scene.objects.active = obj
            for mod in obj.modifiers:
                try:
                    bpy.ops.object.modifier_apply(apply_as='DATA',
                    modifier = mod.name)
                except:
                    pass
    scene.objects.active = bpy.data.objects[origActive]
    bpy.context.active_object.select = True                         
    bpy.ops.object.join()
def fu18():
    if len(bpy.data.lamps) < 1:
        newLamp = bpy.data.lamps.new(name='Basic Lamp',type ='HEMI')
        txt1 = 'No lamps were found in the scene, so one was created ' 
        txt2 = 'because it was required for this type of baking process.'
    else:
        visibleLamp = False
        for ob in bpy.data.objects:
            if ob.type == 'LAMP':
                if ob.hide_render is False:
                    visibleLamp = True
                    break
        if visibleLamp == False:
            for ob in bpy.data.objects:
                if ob.type == 'LAMP':
                    ob.hide_render = False
                    break
def fu19():
    wm = bpy.context.window_manager
    try:
        default, state = addon_utils.check("Alchemy")
        if state:      
            ob = bpy.context.active_object
            if wm.sfMatLibOn:
                if bpy.context.mode == 'PAINT_VERTEX':                    
                    if ob.active_material:
                        if mode != 'OBJECT':       
                            bpy.ops.object.sf_matlib_mat_paint(func="finish_painting")                
                wm.sfMatLibOn = False
            if ' Painted' in ob.data.materials[0].name:
                mName = ob.data.materials[0].name
                ob.data.materials[0].name = mName[:-8]
    except:
        pass   
def fu20(bake_type):
    bpy.ops.object.mode_set(mode='OBJECT')
    selected = bpy.context.selected_objects
    scene = bpy.context.scene
    wm = bpy.context.window_manager
    renEng = scene.render.engine
    mode = bpy.context.mode
    if scene.zbFastMode:
        scene.zbFastMode = False
    if mode == 'PAINT_TEXTURE':
        bpy.ops.object.zb_save_layers(save_only_active=True)    
    if renEng == 'CYCLES':
        if scene.zbQuickLights:
            for obj in bpy.data.objects:
                if 'zbCyclesLight' in obj.name:
                    obj.hide = False
                    obj.select = False
    faces = 0
    abort = False
    userMessage = ''    
    mType = ['SURFACE','FONT','META','CURVE']
    for obj in selected:
        try: 
            if hasattr(obj.data,'materials') is False:
                print(obj.name,'Does not use materials. Deselecting for bake.')
                obj.select = False
            if obj.select != False:
                if hasattr(obj.data,'uv_textures') is False:
                    print(obj.name,'Does not use uv mapping. Deselecting for bake.')
                    obj.select = False                              
        except:
            pass
        try: 
            badEgg = True
            for m in mType:
                if m not in obj.type:
                    badEgg = False
            if badEgg:
                if obj.dupli_type == 'GROUP':
                    userMessage = "Group instances must be made unique before baking"
                    abort = True
                    break
                else:
                    userMessage = obj.type + ' type objects can not be baked'
                    abort = True
                    break
        except:
            abort = True
        try: 
            if obj.type != 'MESH':
                for m in mType:
                    if m in obj.type:
                        bpy.ops.object.sf_convert()
                        break
                if obj.type != 'MESH':
                    obj.select = False
            else:
                if len(obj.data.polygons) < 1:
                    obj.select = False
                else:
                    faces += len(obj.data.polygons)
        except:
            abort = True
        try: 
            if obj.modifiers:
                for mod in obj.modifiers:
                    if mod.type == 'SOLIDIFY':
                        mod.show_render = False
                        mod.show_viewport = False  
        except:
            pass                    
    if len(bpy.context.selected_objects) < 1:
        abort = True
    if abort:
        if userMessage == '':
            userMessage = 'Can not bake'  
    if renEng == 'BLENDER_RENDER':
        if bake_type == 'MERGE_NORMALS':
            bake_type = 'NORMALS'
        scene.render.bake_type = bake_type
    if scene.zbUserBakeSettings:
        mSize = scene.render.bake.margin
    else:
        mSize = 5
        if scene.zbImgSize < 513:
            mSize = 2
        if scene.zbImgSize > 1023:
            mSize = 8
        if scene.zbImgSize > 2047:
            mSize = 12
        scene.render.bake_bias = .015
        scene.render.use_bake_clear = False
        scene.render.bake_margin = mSize   
        scene.render.bake_distance = 1      
    scene.render.bake_samples = 512
    if scene.zbBakeSelectedToActive is False:
        if renEng != 'CYCLES':
            if scene.zbBakeSingle:
                fu14()        
    return abort, mSize, userMessage
def fu21(mat):
    scene = bpy.context.scene
    ob = bpy.context.active_object
    tex = mat.active_texture
    needNodes = True
    if hasattr(mat.node_tree,'nodes'):
        if 'Normal Map zbNormal' in mat.node_tree.nodes: 
            mat.node_tree.nodes['Image Texture zbNormal'].image = tex.image
            needNodes = False
        if 'Diffuse BSDF zbColor' not in mat.node_tree.nodes:
            if scene.render.engine == 'BLENDER_RENDER':
                scene.zbGoCycles = True
                scene.render.engine = 'BLENDER_RENDER'
    else:
        if scene.render.engine == 'BLENDER_RENDER':
            scene.zbGoCycles = True
            scene.render.engine = 'BLENDER_RENDER'
    if needNodes:                        
        node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
        node.label = node.name + ' zb' + 'Normal'
        node.name = node.label
        nodeTex = node
        nodeTex.color_space = 'NONE'
        nodeTex.image = tex.image
        node = mat.node_tree.nodes.new(type = 'ShaderNodeNormalMap')
        node.label = node.name + ' zb' + 'Normal'
        node.name = node.label
        nodeNormal = node
        nodeNormal.uv_map = 'UVMap'
        nodeNormal.inputs[0].default_value = 5
        nodeDifCol = mat.node_tree.nodes['Diffuse BSDF zbColor']
        mat.node_tree.links.new(nodeTex.outputs['Color'], nodeNormal.inputs['Color'])
        mat.node_tree.links.new(nodeNormal.outputs['Normal'], nodeDifCol.inputs['Normal'])
        mat.node_tree.nodes[nodeTex.name].hide = True
        mat.node_tree.nodes[nodeNormal.name].hide = True
        nodeTex.location = (120, -105)
        nodeNormal.location = (120, -160)
    try:
        normalMapNode = mat.node_tree.nodes['Normal Map zbNormal']
        normalMapNode.uv_map = ob.data.uv_textures.active.name
    except:
        pass
class cl21(bpy.types.Operator):
    bl_idname =i_0[70]
    bl_label =i_0[71]
    bl_description =i_0[72]
    msg = bpy.props.StringProperty()
    def execute(self,context):
        bpy.ops.object.zb_message('INVOKE_DEFAULT',message = self.msg)
        return{'CANCELLED'}
def fu22(message):  
    brBakeTypes = ['FULL', 'AO', 'SHADOW', 'NORMALS', 'TEXTURE', 
    'DISPLACEMENT', 'DERIVATIVE', 'VERTEX_COLORS', 'EMIT', 'ALPHA',         
    'MIRROR_INTENSITY', 'MIRROR_COLOR', 'SPEC_INTENSITY', 'SPEC_COLOR']        
    cyBakeTypes = ['COMBINED', 'AO', 'SHADOW', 'NORMAL', 'UV', 'EMIT', 
    'ENVIRONMENT', 'DIFFUSE', 'GLOSSY', 'TRANSMISSION', 'SUBSURFACE']
    if message in brBakeTypes or message in cyBakeTypes:                    
        bpy.ops.object.zb_bake(bake_type = message)    
    if message == "MERGE_NORMALS":
        bpy.ops.object.zb_bake(bake_type='MERGE_NORMALS')
    if message == "MERGE_LAYERS":
        bpy.ops.object.zb_bake(bake_type='TEXTURE')
    if message == 'LAYER_FROM_BRUSH':
        bpy.ops.object.zb_layer_from_brush(action='START')  
class cl22(bpy.types.Operator):
    bl_idname =i_0[73]
    bl_label =i_0[74]
    bl_description =i_0[75]
    message = bpy.props.StringProperty()
    def execute(self, context):
        fu22(self.message)                  
        return {'FINISHED'}
    def draw(self, context):
        scene = bpy.context.scene
        renEng = scene.render.engine
        message = self.message
        layout = self.layout
        sub = layout.column()
        sub.scale_y = 0.75
        brBakeTypes = ['FULL', 'AO', 'SHADOW', 'NORMALS', 'TEXTURE', 
        'DISPLACEMENT', 'DERIVATIVE', 'VERTEX_COLORS', 'EMIT', 'ALPHA',         
        'MIRROR_INTENSITY', 'MIRROR_COLOR', 'SPEC_INTENSITY', 'SPEC_COLOR']        
        cyBakeTypes = ['COMBINED', 'AO', 'SHADOW', 'NORMAL', 'UV', 'EMIT', 
        'ENVIRONMENT', 'DIFFUSE', 'GLOSSY', 'TRANSMISSION', 'SUBSURFACE']
        useMultires = False
        if 'NORMAL' in message:
            try:
                ob = bpy.context.active_object                
                for mod in ob.modifiers:
                    if mod.type == 'MULTIRES':
                        useMultires = True
                        break
            except:
                pass
        if message in brBakeTypes or message in cyBakeTypes:
            defaultMessage = True      
            if renEng == 'CYCLES':
                if message == 'SHADOW':
                    defaultMessage = False
                    sub.label('"SHADOW" BAKE:',icon='SOLO_ON')
                    sub.label('Shadow maps baked in Cycles can only use light from')
                    sub.label('actual Blender lamps to create shadows (this is default')
                    sub.label('Blender behaviour). Light from your environment or')
                    sub.label('materials using emission will not render in the bake.')
                    sub.label('')
                    sub.label('Press Shift-A > Lamp and add a lamp for shadow bakes')
                    sub.label('to work. Or else perform a full bake (combined) to use') 
                    sub.label('regular Cycles lighting in your bake.')                   
                if message == 'ENVIRONMENT':
                    defaultMessage = False
                    sub.label('"ENVIRONMENT" BAKE:',icon='SOLO_ON')
                    sub.label('This type of bake will only bake light coming from')  
                    sub.label('your world environment on to your selection. So if')
                    sub.label('you have an environment image attached to your world')
                    sub.label('output such as clouds, this will show up on what ever')
                    sub.label('you bake.')
            if message == 'VERTEX_COLORS':
                    defaultMessage = False
                    sub.label('"VERTEX COLORS" BAKE:',icon='SOLO_ON')
                    sub.label("This will bake the object's vertex colors to an")
                    sub.label("image. If you haven't painted vertex colors onto")
                    sub.label('an object, then the bake will appear totally black.')
            if message == 'DISPLACEMENT':
                defaultMessage = False
                sub.label('"DISPLACEMENT" BAKE:',icon='SOLO_ON')
                sub.label('The baked displacement map will not be integrated')
                sub.label("into the default ZB layer system. To use this map")
                sub.label('after it is baked, add a displace modifier to a similar')
                sub.label('shaped object as the one baked. Then set the displace')
                sub.label("modifier's texture to the baked image.")
                sub.label('')
                sub.label('The object must have a lot of faces for the baked map')
                sub.label('to work or else first add a subsurface modifier to the') 
                sub.label('object before adding the displace modifier. If the')
                sub.label('object is using the same uv map as the one baked, be')
                sub.label('sure to set the modifiers "Tex Coordinates" to "UV".')
            if scene.zbBakeSingle:                              
                if defaultMessage is False:
                    sub.label('')
                defaultMessage = False                
                if useMultires == False:  
                    sub.label('"Bake To Single" is activated. All of the selected',
                    icon='SOLO_ON')
                    sub.label('objects will bake to a single map and material. Since')
                    sub.label('these objects share a map, their resolution will lower') 
                    sub.label('so you may wish to increase the "New Layer Size" in')
                    sub.label('the settings before baking.')
                    sub.label('')
                    sub.label('When the bake is finished, all selected objects will')
                    sub.label('posses the same material (though the bake will reflect')
                    sub.label('the materials they were using). To bake multiple objects')
                    sub.label('(but bake them to individual maps & materials), uncheck')
                    sub.label('the "Bake To Single" option in the ZB options menu.')
                try:
                    ob = bpy.context.active_object
                    if ob.data.uv_textures:
                        if 'Shared-UVMap' not in ob.data.uv_textures.active.name:
                            sub.label('')
                            sub.label('The objects you are about to bake have uv maps.',icon ='SOLO_ON')
                            sub.label('Baking them to one image will construct a new merged')
                            sub.label("uv-map for all objects in the selection. If you manually")
                            sub.label('unwrapped these objects and intend to paint them in')
                            sub.label('other software, it would probably be best to disable')
                            sub.label('"Bake To Single" before baking so that the objects being')
                            sub.label('baked keep their own uv maps, images and materials.')                            
                except:
                    pass
            if 'NORMAL' in message:
                defaultMessage = False   
                try:
                    ob = bpy.context.active_object
                    if ob.data.uv_textures:
                        if 'Shared-UVMap' not in ob.data.uv_textures.active.name:
                            if len(bpy.context.selected_objects) > 1:
                                sub.label('')
                except:
                    pass         
                abortNormalBake = False
                if ob.active_material:
                    if not ob.data.uv_textures:
                        abortNormalBake = True
                if abortNormalBake:
                    sub.label('You can bake normals for objects with no materials',
                    icon='ERROR')
                    sub.label('or objects that have already been baked or painted')
                    sub.label('but not objects with basic materials which have not')
                    sub.label('been either ZB painted or baked first. Switch to object')
                    sub.label('mode and perform a full bake first.')
                    self.message = 'CANCEL'
                else:                    
                    if useMultires:
                        sub.label('This will convert the sculpt detail of your mesh',icon='SOLO_ON')
                        sub.label('into a normal map that will be applied to your')
                        sub.label('material and be visible in both BR & Cycles. This')
                        sub.label("method of normal baking uses an object's multires")
                        sub.label('modifier to bake from.')
                    else:
                        sub.label('This will bake detail from the high-poly mesh onto the',icon='SOLO_ON')
                        sub.label('low-poly mesh. Make sure the objects are in the same')
                        sub.label('position and that the high-poly mesh was selected first')
                        sub.label('then shift-select the object you want the detail baked to.')
                    sub.label('')    
                    sub.label(' When the bake is complete you can press the ZB tex-')
                    sub.label('-ture paint button to enter texture paint mode and')
                    sub.label('adjust the normal value of the layer. You can control')
                    sub.label('the size of the normal map by adjusting the "New Layer')
                    sub.label('Width & Height" values in the options before you bake.')
            if defaultMessage:         
                sub.label('Baking is a rendering process which may take a few')
                sub.label('minutes to up to an hour depending on the size. You')
                sub.label('can control the size of the bake image by adjusting')
                sub.label('the "New Layer Width & Height" values in the options')
                sub.label('menu as well as the "Bake Quality" before baking.')    
                sub.label('')
                sub.prop(scene,'zbDisablePopup',text='Disable Messages') 
                sub.label('(enable in options menu)')                                     
            sub.label('')
            sub.label('PROCEED WITH BAKE?')
        if message == 'TRADITIONAL_NORMALS_BAKE':
            sub.label('You must first select the high-poly model you want',
            icon='ERROR')
            sub.label('to acquire the detail from, then shift-select the')
            sub.label('lower-poly model you want to bake the map onto')
            sub.label('before performing a "Normal","Displacement" or')
            sub.label('"Derivative" bake. The two objects should also be')
            sub.label('in the same location (or very close).')
            sub.label('')     
            sub.label('You can only bake one map at a time when using')
            sub.label('this traditional method. This means you should')
            sub.label('only have two objects selected. You can also bake')
            sub.label('a normal or displacement map for objects using')
            sub.label("multires-modifiers. In that case, you would only")
            sub.label('have to select the object with the multires')
            sub.label('modifier before baking and you could bake multiple')
            sub.label('objects at a time.')
            sub.label('')   
        if message == 'MERGE_NORMALS':
            sub.label("This will merge (and convert) all of the material's")
            sub.label("bump & normal layers into a new normal map (includ-")
            sub.label('-ing bump effects from color layers). This is a bake')
            sub.label('process which may take a few minutes or longer.')
            sub.label('')
            sub.label('Use the "New Layer Size" option to define how big you')
            sub.label('want the map to be, or exclude layers from the merge')
            sub.label('by clicking the eye icon next to them (while in texture')
            sub.label('paint mode) to hide them before baking. No layers will')
            sub.label('be deleted, just a new one created.')
            sub.label('')
            sub.label('PROCEED WITH MERGER?')
        if message == 'MERGE_LAYERS':
            sub.label("This will merge all of the material's color (diffuse),")
            sub.label("layers into a new single color layer. You can use the")
            sub.label('"New Layer Size" option to define how big you want')
            sub.label('the new layer to be before merging, or exclude layers')
            sub.label('by clicking the eye icon next to them to hide them.')
            sub.label('')
            sub.label('Once finished, the layers used to create the merged')
            sub.label('layer will be hidden displaying only the merged layer.')
            sub.label('No layers will be deleted, just a new one created.')
            sub.label('This process may take a few minutes to complete.')
            sub.label('')
            sub.label('PROCEED WITH MERGER?') 
        if message == 'LAYER_FROM_BRUSH':
            sub.label('If you have a texture brush loaded, this option will')
            sub.label('allow you to create a new layer from the brush image.')
            sub.label('This is especially useful when using seamless texture')
            sub.label('brushes like those found at blendersensei.com')
            sub.label('')
            sub.label('This happens in two parts. The first part lets you')
            sub.label('adjust the position and scale of the repeating image.')
            sub.label('There is also a button to re-apply the brush image')
            sub.label('from your current view. When you are satisfied with')
            sub.label('the results press "Finish Brush Layer" to bake the')
            sub.label('final image as a new, regular Zero Brush layer.')
            sub.label('')
            sub.label('NOTE: If you are in Cycles, you will be temporarily')
            sub.label('transported to Blender Render while adjusting your')
            sub.label('new layer. You will return to your previous render')
            sub.label('engine after pressing "Finish Brush Layer".')
            sub.label('')
            sub.label('CREATE A LAYER FROM THE BRUSH IMAGE?')
    def invoke(self, context, event):
        scene = bpy.context.scene
        if scene.zbDisablePopup:
            fu22(self.message)
            return {'FINISHED'}
        else:
            width = 325
            height = bpy.context.window.height/2
            return context.window_manager.invoke_props_dialog(self, width, height)
class cl23(bpy.types.Menu):
    bl_label =i_0[76]
    bl_idname =i_0[77]
    def draw(self, context):
        scene = bpy.context.scene
        re = scene.render.engine
        wm = bpy.context.window_manager
        layout = self.layout
        col = layout.column()
        col.prop(scene, 'zbAutoSaveLayers', text= 'Autosave Layers')
        col.prop(scene, 'zbSaveWhenSave', text= 'Autosave (with file)')
        col.prop(scene, 'zbPrecisePaintOption', text = 'Precise Paint Mode')
        col.prop(scene, 'zbDistractionFreeMode', text = 'Distraction Free')
        col.prop(scene, "zbDisableShadows", text = "Disable Shadows")
        col.prop(scene,'zbDisablePopup',text='Disable Messages') 
        col.prop(scene, 'zbUserBakeSettings')
        col.prop(scene, 'zbUseLightMap', text = 'Use Lightmap UVs')
        col.prop(scene, 'zbLoadImgSculpt', text = 'Texture & Sculpt')         
        col.prop(scene, 'zbAutoConvertCycles', text = 'Auto Convert Cycles')
        col.prop(scene, 'zbAutoConvertLamps', text= 'Auto Convert Lamps')
        col.prop(scene, 'zbAutoGPURender')
        default, state = addon_utils.check("Alchemy")
        if state:
            col.prop(scene, 'zbAState',text='Alchemy Paint')
class cl24(bpy.types.Menu):
    bl_label =i_0[78]
    bl_idname =i_0[79]
    def draw(self, context):
        scene = bpy.context.scene
        re = scene.render.engine
        wm = bpy.context.window_manager
        mode = bpy.context.mode
        tSet = bpy.context.tool_settings
        ob = bpy.context.active_object
        ncIcon = 'LINK'   
        hIcon = 'INLINK'
        layout = self.layout
        col = layout.column()
        try:
            mat = ob.active_material
        except:
            mat = 0
        col.menu("menu.zb_system_options", text = 'ZB Options', icon=hIcon)
        col.operator('object.zb_image_edit',text='Image Editor',
        icon=ncIcon).func = 'to_image_editor'
        col.prop(scene, "zbGoCycles", text="Use Cycles")
        if re == 'CYCLES':
            col.prop(scene, "zbQuickLights", text = "Quick Lights")
        col.prop(scene, "zbFastMode", text="Fast Mode")
        col.separator()
        col.menu('menu.zb_bake_type_select',text='Bake Selected',icon=hIcon)
        col.prop(scene,'zbBakeSelectedToActive',text='Sel-to-Active')
        col.prop(scene,'zbBakeSingle',text = 'Bake To Single')        
        if re == 'CYCLES': 
            scene = context.scene
            cscene = scene.cycles
            col.prop(cscene, "samples", text="       Bake Quality")
        else:
            ls = scene.world.light_settings
            col.prop(ls, "samples", text="       Bake Quality")
        col.separator()  
        col.menu("menu.zb_material_options_menu", text = 'Material Options', icon=hIcon) 
        col.separator()
        col.label('Layer Options',icon=hIcon)
        col.operator("object.zb_save_layers", text="Save My Layers",
        icon=ncIcon)
        if context.mode == 'PAINT_TEXTURE':
            if tSet.image_paint.brush.texture:
                col.operator("object.zb_message_proxy",text = 'Layer From Brush',
                icon=ncIcon).msg = 'LAYER_FROM_BRUSH'
        if mat:
            if re != 'CYCLES':
                col.operator('object.zb_message_proxy',text='Merge Layers',
                icon=ncIcon).msg = 'MERGE_LAYERS'
            col.operator('object.zb_message_proxy',text='Merge Normals',
            icon=ncIcon).msg = 'MERGE_NORMALS'
        col.prop(wm, "zbUseBrushColor", text= "Color New Layers")
        col.prop(scene, "zbImgSize", text='       New Layer Width')
        col.prop(scene, "zbImgSizeH", text='       New Layer Height')
class cl25(bpy.types.Operator):
    bl_idname =i_0[80]
    bl_label =i_0[81]
    bl_description =i_0[82]
    def execute(self,context):
        scene = bpy.context.scene
        ob = bpy.context.active_object
        mat = ob.active_material
        try: 
            if ob.dupli_type == 'GROUP':
                oldName = ob.dupli_group.name
                newGroupSel = []
                empty = 0
                bpy.ops.object.duplicates_make_real()
                sel = bpy.context.selected_objects
                for ob in sel:
                    if ob.type == 'EMPTY':
                        empty = ob
                        ob.select = False
                        newGroupSel = bpy.context.selected_objects
                bpy.ops.object.select_all(action='DESELECT')
                for ob in bpy.data.objects:
                    if ob.type == 'EMPTY':
                        if 'group' in ob.name:
                            ob.select = True
                bpy.ops.object.delete()
                for ob in newGroupSel:
                    ob.select = True
                    ob.data = ob.data.copy()
        except:
            pass
        sel = bpy.context.selected_objects
        mode = bpy.context.mode
        if 'PAINT' in mode:
            bpy.ops.object.mode_set(mode='OBJECT')
        for ob in sel:
            bpy.ops.object.select_all(action='DESELECT')
            scene.objects.active = ob
            ob.select = True
            mat = ob.active_material
            if mat:
                if mat.users < 2:
                    ob.active_material = mat.copy()
                bpy.ops.object.zb_save_layers(save_only_active=True)
                slot = ob.active_material_index
                newMat = ob.active_material.copy()
                ob.material_slots[slot].material = newMat
                mat = bpy.context.active_object.active_material
                for slot in mat.texture_slots:
                    try:
                        newTex = slot.texture.copy()
                        newImg = slot.texture.image.copy()
                        slot.texture = newTex
                        slot.texture.image = newImg
                    except:
                        pass
                try: 
                    tn = mat.active_texture_index
                    fu12(context, tn)
                except:
                    pass
        if mode == 'OBJECT':
            bpy.ops.object.select_all(action='DESELECT')
            for ob in sel:
                ob.select = True
        fu1(mode)
        scene.update_tag()
        scene.update()
        return{'FINISHED'}
def fu23(self, context):
    scene = bpy.context.scene
    wm = bpy.context.window_manager
    brushSettings = scene.tool_settings.image_paint
    mat = bpy.context.object.active_material
    if wm.zbPaintThrough == True:
        brushSettings.use_occlude = False
        brushSettings.use_normal_falloff = False
        brushSettings.use_backface_culling = False
    else:
        brushSettings.use_occlude = True
        brushSettings.use_normal_falloff = True
        brushSettings.use_backface_culling = True
    if scene.zbDisableShadows:
        for lamp in bpy.data.lamps:
            uses = False
            try:
                if lamp.shadow_method == 'RAY_SHADOW':
                    uses = True
                if lamp.shadow_method == 'BUFFER_SHADOW':
                    uses = True
            except:
                pass
            if uses:
                lamp.shadow_method = 'NOSHADOW'
    else:
        for lamp in bpy.data.lamps:
            try:
               lamp.shadow_method = 'RAY_SHADOW'
            except:
                pass
def fu24(self,context):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    mode = bpy.context.mode
    sel = bpy.context.selected_objects
    if self.zbQuickLights:            
        world = scene.world
        if not world:
            bpy.ops.world.new()                
            world = bpy.data.worlds[0]
            scene.world = world
        worldWasUsingMist = False
        if world.mist_settings.use_mist:
            worldWasUsingMist = True
        try: 
            wName = scene.world.name
            scene.zbLastWorld = wName
            if 'ZB Quick Lights' in wName:
                try:
                    scene.zbLastWorld = bpy.data.worlds[2].name
                except:
                    scene.zbLastWorld = bpy.data.worlds[0].name
        except:
            w = bpy.context.data.worlds.new('Basic World')
            scene.zbLastWorld = w.name
        try:
            bpy.ops.object.mode_set(mode='OBJECT')
            activeOb = bpy.context.active_object
            bpy.ops.object.select_all(action='DESELECT')
        except:
            pass
        needWorld = False
        for world in bpy.data.worlds:
            if 'ZB Quick Lights' in world.name:
                needWorld = False
                zbQuickLights = world
                scene.world = bpy.data.worlds[world.name]
                break
            else:
                needWorld = True
        if needWorld:
            zbQuickLights = bpy.data.worlds.new("ZB Quick Lights")
            zbQuickLights.horizon_color = [0,0,0]
            zbQuickLights.zenith_color = [0,0,0]
            zbQuickLights.ambient_color = [0,0,0]
            scene.world = zbQuickLights
            zbQuickLights.use_nodes = True
            zbQuickLights.use_fake_user = True
            bg = zbQuickLights.node_tree.nodes['Background']
            bg.inputs[0].default_value = (0,0,0,1)
        needPlanes = False
        if 'zbCyclesLight' not in bpy.data.objects:
            needPlanes = True
        if needPlanes:
            scene.cursor_location.xyz = [0,0,0]
            bpy.ops.mesh.primitive_plane_add()
            bpy.context.active_object.name = "zbCyclesLight"
            ob = bpy.context.active_object
            zbCyclesLight = bpy.context.active_object
            zbCyclesLight.scale = [17,17,17]
            zbCyclesLight.location.z = 100
            zbCyclesLight.active_material = bpy.data.materials.new("zbCyclesLight")
            bpy.ops.object.modifier_add(type='SUBSURF')
            zbCyclesLight.modifiers["Subsurf"].levels = 3
            bpy.ops.object.modifier_apply(apply_as='DATA', modifier="Subsurf")
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.dissolve_limited()
            bpy.ops.object.mode_set(mode='OBJECT')
            mat = ob.active_material
            mat.use_nodes = True
            mat.node_tree.nodes.clear()
            nodeEmission = mat.node_tree.nodes.new(type = 'ShaderNodeEmission')
            nodeEmission.inputs[1].default_value = 20
            nodeOutput = mat.node_tree.nodes.new(type = 'ShaderNodeOutputMaterial')
            mat.node_tree.links.new(nodeEmission.outputs['Emission'],
            nodeOutput.inputs['Surface'])
            nodeOutput.location = (250,0)
            ob.cycles_visibility.camera = False
            ob.cycles_visibility.shadow = False
            bpy.ops.object.duplicate_move()
            ob = bpy.context.active_object
            ob.location.xyz = [-75,-65,15]
            ob.rotation_euler.y = 115
            ob.rotation_euler.z = 45
            ob.scale = [15,15,15]
            bpy.ops.object.duplicate_move()
            ob = bpy.context.active_object
            ob.location.xyz = [75,-65,15]
            ob.rotation_euler.y = -115
            ob.rotation_euler.z = -45
            bpy.ops.object.duplicate_move()
            ob = bpy.context.active_object
            ob.location.xyz = [0,100,15]
            ob.rotation_euler[2] = 1.5708
            for ob in bpy.data.objects:
                if "zbCyclesLight" in ob.name:
                    scene.objects.active = ob
                    ob.select = True
            scene.objects.active = bpy.data.objects["zbCyclesLight"]
            bpy.ops.object.parent_set(type='OBJECT')
        for ob in bpy.data.objects:
            if "zbCyclesLight" in ob.name:               
                ob.select = False
                ob.hide = True
        try:  
            scene.objects.active = activeOb
            scene.objects.active.select = True
        except:
            pass
        try: 
            if worldWasUsingMist:
                bpy.ops.object.sf_cam_options(func="mist")
        except:
            pass
    else: 
        if scene.zbLastWorld:
            lastWorld = scene.zbLastWorld
            if lastWorld in bpy.data.worlds:
                scene.world = bpy.data.worlds[lastWorld]
            else:
                for world in bpy.data.worlds:
                    if 'ZB Quick Lights' not in world.name:
                        scene.world = world
                        break          
            if scene.world.name == 'ZB Quick Lights':
                bpy.ops.world.new()
                for world in bpy.data.worlds:
                    if world.name != 'ZB Quick Lights':
                        scene.world = world
                        break
        try:
            activeOb = bpy.context.active_object
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.select_all(action='DESELECT')
            for mat in bpy.data.materials:
                if "zbCyclesLight" in mat.name:
                    try:
                        bpy.data.materials.remove(mat, do_unlink = True)
                    except:
                        if mat.users:
                            mat.user_clear()
                            bpy.data.materials.remove(mat)
        except:
            pass
        try: 
            if 'ZB Quick Lights' in bpy.data.worlds:
                x = bpy.data.worlds["ZB Quick Lights"]                
                try:
                    bpy.data.worlds.remove(x, do_unlink = True)
                except:
                    if x.users:
                        x.user_clear()    
                    bpy.data.worlds.remove()
        except:
            pass
        for ob in bpy.data.objects:
            if "zbCyclesLight" in ob.name:
                ob.select = False
                scene.objects.unlink(ob)
        fu0()
        try: 
            bpy.ops.object.select_all(action='DESELECT')
            scene.objects.active = activeOb
            scene.objects.active.select = True
        except:
            pass
    try: 
        fu1(mode)
    except:
        pass
    for ob in sel:
        ob.select = True
class cl26(bpy.types.Operator):
    bl_idname =i_0[83]
    bl_label =i_0[84]
    bl_description =i_0[85]
    resetLayer = bpy.props.BoolProperty(default = True) 
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        mode = bpy.context.mode
        userMsg = ''
        bpy.ops.object.mode_set(mode='EDIT')
        bpy.ops.mesh.select_all(action='SELECT')        
        ob = bpy.context.active_object
        mesh = ob.data
        fu10(ob)
        if self.resetLayer:
            layers = len(ob.active_material.texture_paint_images)            
            if layers == 1:
                layer = 0
                for ts in ob.active_material.texture_slots:
                    try:
                        ts.texture.image
                        break
                    except:
                        pass
                    layer += 1
                bpy.ops.object.zb_delete_texture(tex_kill=layer)
                bpy.ops.object.zb_paint_color()
                userMsg = "Reset uvs and layer (this will also reset your image if only one layer)"
        fu1(mode)
        if userMsg:
            self.report({'INFO'}, userMsg)
        return{'FINISHED'}
class cl27(bpy.types.Operator):
    bl_idname =i_0[86]
    bl_label =i_0[87]
    bl_description =i_0[88]
    vpShade = bpy.props.StringProperty(default='MATERIAL')    
    def execute(self, context):
        wm = bpy.data.window_managers["WinMan"]
        scene = bpy.context.scene
        mode = bpy.context.mode
        re = scene.render.engine
        farthestLeft = 0
        farthestLeftShade = 0
        if bpy.context.screen.name == 'Shader':
            v3d_list = [area for area in bpy.context.screen.areas if area.type == 'VIEW_3D']         
            if v3d_list:
                farthestRight = max(v3d_list, key=lambda area: area.x)               
                sd = farthestRight.spaces[0]
                farthestLeft = min(v3d_list, key=lambda area: area.x)
                farthestLeftShade = farthestLeft.spaces[0].viewport_shade 
                farthestLeft.spaces[0].viewport_shade = 'BOUNDBOX'                    
        else:
            sd = bpy.context.space_data
        turnOn = False
        if sd.viewport_shade != 'RENDERED':
            turnOn = True
        if bpy.context.screen.name == 'Shader':
            if scene.cycles.preview_pause:
                turnOn = True
        if turnOn:                  
            if re == 'CYCLES':
                try: 
                    if scene.cycles.feature_set == 'EXPERIMENTAL':                    
                        bpy.ops.object.editmode_toggle()
                        bpy.ops.object.editmode_toggle()
                except:
                    pass
            if farthestLeft == 0: 
                self.vpShade = sd.viewport_shade  
            else:
                if farthestLeftShade:
                    self.vpShade = farthestLeftShade
            if mode == 'PARTICLE':
                bpy.ops.object.mode_set(mode='OBJECT')
                wm.zbLastObjectMode = mode                
                self.report({'INFO'}, 
                "Blender does not support render preview in particle mode (temporarily switched modes).")
            scene.cycles.preview_pause = False
            if re == 'CYCLES':
                if scene.zbQuickLights:
                    try: 
                        scnLight = bpy.data.objects['-Scene Light']
                        shadows  = bpy.data.objects['-Shadows']                        
                        scnLight.hide_render = True
                        shadows.hide_render = True                        
                        shadows.hide = True
                        scnLight.hide = True
                    except:
                        pass                
            for ob in bpy.data.objects:
                if ob.type == 'LAMP':
                    if re != 'CYCLES':
                        if not ob.hide_render:
                            ob.hide = False
                    else:
                        if scene.zbAutoConvertLamps:
                            if not ob.hide_render:
                                ob.hide = False            
            if re == 'CYCLES':
                if scene.zbQuickLights:
                    for ob in bpy.data.objects:
                        if 'zbCyclesLight' in ob.name:
                            ob.hide = False
                            for i in range(20):
                                ob.layers[i] = True   
            try: 
                sd.use_render_border = True
                sd.viewport_shade = 'RENDERED'
            except:
                pass
        else: 
            if re == 'CYCLES':                
                if scene.zbQuickLights == True:
                    for ob in bpy.data.objects:
                        if "zbCyclesLight" in ob.name:
                            ob.hide = True
                            for i in range(19):                                
                                ob.layers[i] = False 
                            ob.layers[0] = True
                            ob.layers[19] = False
            for ob in bpy.data.objects:
                if ob.type == 'LAMP':
                    if "Shadows" in ob.name:
                        ob.hide = True
                    if "-Scene Light" in ob.name:
                        ob.hide = True
            if bpy.context.screen.name != 'Shader':                
                sd.viewport_shade = self.vpShade                
            else:
                if re != 'CYCLES':
                    sd.viewport_shade = self.vpShade
            sd.use_render_border = False
            scene.cycles.preview_pause = True
            if farthestLeft != 0:
                farthestLeft = min(v3d_list, key=lambda area: area.x)                 
                farthestLeft.spaces[0].viewport_shade = self.vpShade             
            if wm.zbLastObjectMode == 'PARTICLE':
                wm.zbLastObjectMode = ''
                bpy.ops.object.mode_set(mode='PARTICLE_EDIT')
        fu1(mode)    
        return{'FINISHED'}
def texLayerAdder(layerType, texCol, texOpas, alphaChoice,
    normalChoice):
    try: 
        sys = bpy.context.user_preferences.system
        fontState = sys.use_translate_new_dataname
        sys.use_translate_new_dataname = False
    except:
        pass
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    sd = bpy.context.space_data
    re = scene.render.engine
    ob = bpy.context.active_object
    mat = ob.active_material
    try:
        if layerType == "Transparent" or layerType == "Alpha_Mask":
            ob.show_transparent = True
            if mat:
                n = 0
                for ts in mat.texture_slots:
                    if ts is not None:
                        try:
                            if ts.use_map_alpha == True:
                                ts.texture.image = None
                                ts.texture = None
                                mat.texture_slots.clear(n)
                        except:
                            pass
                    n += 1
            try:
                if layerType == 'Alpha_Mask':
                    for node in bpy.data.materials[mat.name].node_tree.nodes:
                        if 'zbTransparent' in node.name:
                            tree = bpy.data.materials[mat.name].node_tree
                            mixed5 = tree.nodes['Mixed5']
                            mixed6 = tree.nodes['Mixed6']
                            mat.node_tree.links.new(mixed5.outputs['Shader'],
                            mixed6.inputs[1])
                            nodeColor = tree.nodes['Image Texture zbColor']
                            for img in bpy.data.images:
                                if "Color" in img.name:
                                    if ob.name[:4] in img.name:
                                        nodeColor.image = img
                                        break
            except:
                pass
        if mat is None or "None" in mat.name:
            mat = bpy.data.materials.new(ob.name)
            mat.diffuse_shader = 'LAMBERT'
            mat.darkness = 0.8
            mat.strand.use_tangent_shading = False
            mat.strand.root_size = 2.5
            mat.strand.tip_size = 0.25
            mat.strand.width_fade = 0.5
            ob.active_material = mat
        try:
            node = mat.node_tree.nodes['Mixed1']
        except:
            mat.use_nodes = True
            mat.node_tree.nodes.clear()
            mixedTotal = 8 
            locX = 250 
            mixedList =[] 
            for mixed in range(1,mixedTotal + 1):
                x = mixed
                mixed = mat.node_tree.nodes.new(type="ShaderNodeMixShader")
                mixed.name = "Mixed" + str(x)
                mixed.label = mixed.name
                mixedList.append(mixed)
                mixed.inputs['Fac'].default_value = 0
                locX += 250
                mixed.location = (locX,0)
            nodeOutput = mat.node_tree.nodes.new(type = 'ShaderNodeOutputMaterial')
            nodeOutput.location = (locX + 250,0) 
            node = mat.node_tree.nodes.new(type = 'ShaderNodeMath')
            node.label = node.name + ' zbDisplace'
            node.name = node.label
            nodeMath = node
            nodeMath.location = (locX + 250,-120)
            mat.node_tree.links.new(nodeMath.outputs['Value'],
            nodeOutput.inputs['Displacement'])
            x = 0
            for mixed in mixedList:
                x += 1
                if x < mixedTotal:
                    mixedNext = mixedList[x] 
                    mat.node_tree.links.new(mixed.outputs['Shader'],
                    mixedNext.inputs['Shader'])
                else:
                    mat.node_tree.links.new(mixed.outputs['Shader'],
                    nodeOutput.inputs['Surface'])
                if "5" in mixed.name:
                    mat.node_tree.links.new(mixed.outputs['Shader'],
                    mixedNext.inputs[2])
        w = round(scene.zbImgSize)
        h = round(scene.zbImgSizeH)
        layerName = ob.name[:4] 
        img = bpy.data.images.new(layerName + layerType, scene.zbImgSize, scene.zbImgSizeH, alpha= alphaChoice)
        override = bpy.context.copy()
        override['edit_image'] = img
        bpy.ops.image.pack(override, as_png = True)
        img.pixels[:] = (texCol, texCol, texCol, texOpas) * w * h
        try: 
            brushCol = bpy.context.tool_settings.image_paint.brush.color
            if wm.zbUseBrushColor:
                l = layerType
                go = 0
                if "Bu" not in l:
                    if "Tr" not in l:
                        if "Ma" not in l:
                            go = 1
                if go:
                    img.pixels[:] = (brushCol.r, brushCol.g, brushCol.b, 1) * w * h
        except:
            pass
        cTexName = layerName + layerType
        cTex = bpy.data.textures.new( name = cTexName, type = 'IMAGE')
        activeTex = -1
        for ts in mat.texture_slots:
            activeTex += 1
            if ts is None:
                break
        mTex = mat.texture_slots.add()
        mTex.texture = cTex
        mTex.texture_coords = 'UV'
        if normalChoice == True:
            mTex.use_map_normal = True
            mTex.bump_method = 'BUMP_MEDIUM_QUALITY'
            mTex.normal_factor = 0.0
        cTex.image = img
        bpy.ops.object.mode_set(mode = 'EDIT')
        bpy.ops.mesh.select_all(action='SELECT')
        fu10(ob)
        for uv_face in ob.data.uv_textures.active.data:
            uv_face.image = img
        try: 
            if sd.viewport_shade != 'TEXTURED':
                sd.viewport_shade = 'MATERIAL'
            scene.game_settings.material_mode = 'GLSL'
        except:
            pass
        bpy.ops.object.mode_set(mode = 'TEXTURE_PAINT')
        bleed = 2 
        if w > 512:
            bleed = 5
        if w > 1024:
            bleed = 6
        if w > 2048:
            bleed = 8
        scene.tool_settings.image_paint.seam_bleed = bleed
        bpy.ops.object.zb_set_active_layer(tex_index=activeTex)
        slots = mat.texture_slots
        ts = slots[mat.active_texture_index]
        ctx = bpy.context.copy()
        ctx['texture_slot'] = ts
        x = 0
        while x < 17:
            bpy.ops.texture.slot_move(ctx, type='DOWN')
            x += 1
    except:
        pass
    tn = mat.active_texture_index
    context = bpy.context
    fu12(context,tn)
    if layerType == "Color":
        try:
            nodeTex = mat.node_tree.nodes['Image Texture zbColor']
            nodeTex.mute = False
        except:
            node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeTex = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeMixRGB')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMixRGB = node
            nodeMixRGB.blend_type = 'MIX'
            nodeMixRGB.inputs['Fac'].default_value = 1
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBrightContrast')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBright = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBsdfDiffuse')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeDiffuse = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBump')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBump = node
            nodeBump.inputs[1].default_value = 0.015
            nodeBump.invert = True
            node = mat.node_tree.nodes.new(type='ShaderNodeRGBToBW')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBW = node
            node = mat.node_tree.nodes.new(type='ShaderNodeBsdfGlossy')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeGloss = node
            node = mat.node_tree.nodes.new(type='ShaderNodeMath')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMath = node
            nodeMath.inputs[1].default_value = 0
            nodeMath.operation = 'MULTIPLY'
            node = mat.node_tree.nodes.new(type='ShaderNodeEmission')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeEmission = node
            nodeEmission.inputs[1].default_value = 10
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBsdfTransparent')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeAlpha = node
            mat.node_tree.nodes[nodeBump.name].hide = True
            mat.node_tree.nodes[nodeBW.name].hide = True
            mat.node_tree.nodes[nodeGloss.name].hide = True
            mat.node_tree.nodes[nodeMath.name].hide = True
            mat.node_tree.nodes[nodeBright.name].hide = True
            mat.node_tree.nodes[nodeMixRGB.name].hide = True
            nodeTex.location = (-50, 0)
            nodeMixRGB.location = (120, -5)
            nodeBright.location = (120, -55)
            nodeDiffuse.location = (250, 0)
            nodeMath.location = (250, -130)
            nodeBW.location = (250, -170)
            nodeBump.location = (500, -130)
            nodeGloss.location = (500, -170)
            nodeEmission.location = (750,-130)
            nodeAlpha.location = (1000, -130)
            colorMixed1 = mat.node_tree.nodes['Mixed1']
            colorMixed2 = mat.node_tree.nodes['Mixed2']
            colorMixed3 = mat.node_tree.nodes['Mixed3']
            nodeMath2 = mat.node_tree.nodes['Math zbDisplace']
            nodeMath2.inputs[0].default_value = 0
            mat.node_tree.links.new(nodeTex.outputs['Color'], nodeMixRGB.inputs['Color2'])
            mat.node_tree.links.new(nodeMixRGB.outputs['Color'], nodeBright.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeDiffuse.inputs['Color'])
            mat.node_tree.links.new(nodeDiffuse.outputs['BSDF'], colorMixed1.inputs['Shader'])
            mat.node_tree.links.new(nodeDiffuse.outputs['BSDF'], colorMixed1.inputs['Shader'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeBW.inputs['Color'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeMath.inputs[0])
            mat.node_tree.links.new(nodeMath.outputs['Value'], nodeMath2.inputs[0])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeGloss.inputs['Color'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeBump.inputs['Strength'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeBump.inputs['Height'])
            mat.node_tree.links.new(nodeBump.outputs['Normal'], nodeGloss.inputs['Normal'])
            mat.node_tree.links.new(nodeGloss.outputs['BSDF'], colorMixed1.inputs[2])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeEmission.inputs['Color'])
            mat.node_tree.links.new(nodeEmission.outputs['Emission'], colorMixed2.inputs[2])
            mat.node_tree.links.new(nodeAlpha.outputs['BSDF'], colorMixed3.inputs[2])
            mat.node_tree.links.new(colorMixed2.outputs['Shader'], nodeAlpha.inputs['Color'])
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
    if layerType == "Bump":
        try:
            nodeTex = mat.node_tree.nodes['Image Texture zbBump']
        except:
            node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeTex = node
            nodeTex.color_space = 'NONE'
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBrightContrast')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBright = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeRGBToBW')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBW = node
            node = mat.node_tree.nodes.new(type='ShaderNodeMath')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            node.inputs[1].default_value = 2.5
            nodeMath = node
            nodeMath.operation = 'MULTIPLY'
            nodeOutput = mat.node_tree.nodes['Material Output']
            nodeMath2 = mat.node_tree.nodes['Math zbDisplace']
            mat.node_tree.links.new(nodeTex.outputs['Color'], nodeBright.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeBW.inputs['Color'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeMath.inputs[0])
            mat.node_tree.links.new(nodeMath.outputs['Value'], nodeMath2.inputs[1])
            nodeTex.location = (-50, -260)
            nodeBright.location = (120, -260)
            nodeBW.location = (120, -390)
            nodeMath.location = (285, -260)
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
        try: 
            brush = bpy.context.tool_settings.image_paint.brush
            brush.color = (1,1,1)
        except:
            pass
    if layerType == "Specular":
        try:
            nodeTex = mat.node_tree.nodes['Image Texture zbSpecular']
            mat.node_tree.nodes['Math zbSpecular'].inputs[1].default_value = 1
        except:
            node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeTex = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeMixRGB')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMixRGB = node
            nodeMixRGB.blend_type = 'MIX'
            nodeMixRGB.inputs['Fac'].default_value = 1
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBrightContrast')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBright = node
            node = mat.node_tree.nodes.new(type='ShaderNodeBsdfGlossy')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeGloss = node
            node = mat.node_tree.nodes.new(type='ShaderNodeRGBToBW')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBW = node
            node = mat.node_tree.nodes.new(type='ShaderNodeMath')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMath = node
            nodeMath.operation = 'MULTIPLY'
            nodeMath.inputs[1].default_value = 1
            specularMixed5 = mat.node_tree.nodes['Mixed5']
            mat.node_tree.links.new(nodeTex.outputs['Color'], nodeMixRGB.inputs['Color2'])
            mat.node_tree.links.new(nodeMixRGB.outputs['Color'], nodeBright.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeBW.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeGloss.inputs['Color'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeMath.inputs['Value'])
            mat.node_tree.links.new(nodeGloss.outputs['BSDF'], specularMixed5.inputs[2])
            mat.node_tree.links.new(nodeMath.outputs['Value'], specularMixed5.inputs['Fac'])
            nodeTex.location = (-50, -515)
            nodeMixRGB.location = (120, -520)
            nodeBright.location = (120, -570)
            nodeBW.location = (250,-515)
            nodeMath.location = (250,-605)
            nodeGloss.location = (415,-515)
            mat.node_tree.nodes[nodeBright.name].hide = True
            mat.node_tree.nodes[nodeMixRGB.name].hide = True
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
    if layerType == "Glow":
        try: 
            nodeTex = mat.node_tree.nodes['Image Texture zbGlow']            
            mat.node_tree.nodes['Math zbGlow'].inputs[1].default_value = 6.5
        except:
            node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeTex = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeMixRGB')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMixRGB = node
            nodeMixRGB.blend_type = 'MIX'
            nodeMixRGB.inputs['Fac'].default_value = 1
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBrightContrast')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBright = node
            node = mat.node_tree.nodes.new(type='ShaderNodeEmission')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            node.inputs[1].default_value = 6.5
            nodeEmission = node
            node = mat.node_tree.nodes.new(type='ShaderNodeRGBToBW')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeBW = node
            node = mat.node_tree.nodes.new(type='ShaderNodeMath')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeMath = node
            nodeMath.operation = 'MULTIPLY'
            nodeMath.inputs[1].default_value = 6.5
            glowMixed7 = mat.node_tree.nodes['Mixed7']
            mat.node_tree.links.new(nodeTex.outputs['Color'], nodeMixRGB.inputs['Color2'])
            mat.node_tree.links.new(nodeMixRGB.outputs['Color'], nodeBright.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeBW.inputs['Color'])
            mat.node_tree.links.new(nodeBright.outputs['Color'], nodeEmission.inputs['Color'])
            mat.node_tree.links.new(nodeBW.outputs['Val'], nodeMath.inputs['Value'])
            mat.node_tree.links.new(nodeEmission.outputs['Emission'], glowMixed7.inputs[2])
            mat.node_tree.links.new(nodeMath.outputs['Value'], glowMixed7.inputs['Fac'])
            nodeTex.location = (-50, -790)
            nodeMixRGB.location = (120, -795)
            nodeBright.location = (120, -845)
            nodeBW.location = (250,-790)
            nodeMath.location = (250,-880)
            nodeEmission.location = (415,-790)
            mat.node_tree.nodes[nodeBright.name].hide = True
            mat.node_tree.nodes[nodeMixRGB.name].hide = True
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
    if layerType == "Transparent":
        try: 
            nodeTex = mat.node_tree.nodes['Image Texture zbColor']
            nodeTex.mute = False
        except:
            bpy.ops.object.zb_paint_color()
            nodeTex = mat.node_tree.nodes['Image Texture zbColor']
        if nodeTex.outputs['Alpha'].is_linked == False:
            try:
                nodeAlpha = mat.node_tree.nodes['Transparent BSDF zbTransparent']
            except:
                node = mat.node_tree.nodes.new(type = 'ShaderNodeBsdfTransparent')
                node.label = node.name + ' zb' + layerType
                node.name = node.label
                nodeAlpha = node
            Mixed5 = mat.node_tree.nodes['Mixed5']
            Mixed6 = mat.node_tree.nodes['Mixed6']
            mat.node_tree.links.new(nodeTex.outputs['Alpha'], Mixed6.inputs['Fac'])
            mat.node_tree.links.new(Mixed5.outputs['Shader'], nodeAlpha.inputs['Color'])
            mat.node_tree.links.new(nodeAlpha.outputs['BSDF'], Mixed6.inputs['Shader'])
            mat.node_tree.links.new(Mixed5.outputs['Shader'], Mixed6.inputs[2])
            nodeAlpha.location = (1750, -130)
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
    if layerType == "Alpha_Mask":
        try: 
            nodeTex = mat.node_tree.nodes['Image Texture zbAlpha_Mask']
            nodeTex.mute = False
        except:
            pass
        try:
            Mixed6 = mat.node_tree.nodes['Mixed6']
            nodeAlpha = mat.node_tree.nodes['Transparent BSDF zbAlpha_Mask']
            mat.node_tree.links.new(nodeTex.outputs['Alpha'], Mixed6.inputs['Fac'])
            mat.node_tree.links.new(nodeAlpha.outputs['BSDF'], Mixed6.inputs[2])
        except:
            node = mat.node_tree.nodes.new(type = 'ShaderNodeTexImage')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeTex = node
            node = mat.node_tree.nodes.new(type = 'ShaderNodeBsdfTransparent')
            node.label = node.name + ' zb' + layerType
            node.name = node.label
            nodeAlpha = node
            nodeTex.location = (-50, -1075)
            nodeAlpha.location = (250, -1075)
            Mixed6 = mat.node_tree.nodes['Mixed6']
            mat.node_tree.links.new(nodeTex.outputs['Alpha'], Mixed6.inputs['Fac'])
            mat.node_tree.links.new(nodeAlpha.outputs['BSDF'], Mixed6.inputs[2])
        nodeTex.image = img
        node_tree = bpy.data.materials[mat.name].node_tree
        node_tree.nodes.active = nodeTex
    if re != 'CYCLES':
        mat.use_nodes = False
    try: 
        sys = bpy.context.user_preferences.system
        sys.use_translate_new_dataname = fontState
    except:
        pass
    return mTex
class cl28(bpy.types.Operator):
    bl_idname =i_0[89]
    bl_label =i_0[90]
    bl_description =i_0[91]
    def execute(self, context):
        scene = bpy.context.scene
        re = scene.render.engine
        layerType = "Color"
        texCol = 0.9
        texOpas = 1
        try:
            ob = bpy.context.active_object
            if ob.active_material:
                if ob.active_material.texture_paint_images:
                    if re != 'CYCLES':
                        texOpas = 0
                    if 'ZB Painted' in ob.active_material.name:
                        texOpas = 0                    
                    if 'ZBA Painted' in ob.active_material.name:
                        texOpas = 0
        except:
            pass
        alphaChoice = True
        normalChoice = True
        texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        return {'FINISHED'}
class cl29(bpy.types.Operator):
    bl_idname =i_0[92]
    bl_label =i_0[93]
    bl_description =i_0[94]
    def execute(self, context):
        scene = bpy.context.scene
        re = scene.render.engine
        layerType = "Bump"
        texCol = 0.0
        texOpas = 1.0
        alphaChoice = True
        normalChoice = True
        mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        mTex.use_map_color_diffuse = False
        mTex.normal_factor = 0.25
        ob = bpy.context.active_object
        if ob.active_material:
            if ' ZB Painted' in ob.active_material.name:
                if re == 'CYCLES':
                    mat = ob.active_material
                    nodes = mat.node_tree.nodes
                    for node in nodes:
                        if node.name == 'Mix Alchemy Displacement':
                            nodeMixDis = node
                        if node.name == 'Math zbDisplace':
                            nodeZBDisplace = node
                    link = mat.node_tree.links              
                    link.new(nodeMixDis.outputs['Color'], nodeZBDisplace.inputs[0])
        self.report({'INFO'}, "Use white when painting on bump layers")
        return {'FINISHED'}
class cl30(bpy.types.Operator):
    bl_idname =i_0[95]
    bl_label =i_0[96]
    bl_description =i_0[97]
    def execute(self, context):
        layerType = "Specular"
        texCol = 0.0
        texOpas = 0.0
        alphaChoice = True
        normalChoice = False
        mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        ob = bpy.context.active_object
        mat = ob.active_material
        mat.specular_color = (0, 0, 0)
        mat.specular_intensity = 1
        mTex.use_map_color_diffuse = False
        mTex.use_map_color_spec = True
        return {'FINISHED'}
class cl31(bpy.types.Operator):
    bl_idname =i_0[98]
    bl_label =i_0[99]
    bl_description =i_0[100]
    @classmethod
    def poll(cls, context):
        use = False
        ob = bpy.context.active_object
        if ob.active_material:
            if ' ZB Painted' not in ob.active_material.name:
                use = True
        return use
    def execute(self, context):
        layerType = "Transparent"
        texCol = 0.0
        texOpas = 0.0
        alphaChoice = True
        normalChoice = False
        mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        ob = bpy.context.active_object
        mat = ob.active_material
        mat.use_transparency = True
        mat.transparency_method = 'Z_TRANSPARENCY'
        mat.alpha = 0
        mat.specular_intensity = 0
        mTex.use_map_alpha = True
        bpy.context.space_data.show_backface_culling = False
        return {'FINISHED'}
class cl32(bpy.types.Operator):
    bl_idname =i_0[101]
    bl_label =i_0[102]
    bl_description =i_0[103]
    def execute(self, context):
        layerType = "Alpha_Mask"
        texCol = 0.0
        texOpas = 0.0
        alphaChoice = True
        normalChoice = False
        mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        ob = bpy.context.active_object
        mat = ob.active_material
        mat.use_transparency = True
        mat.transparency_method = 'Z_TRANSPARENCY'
        mat.alpha = 0
        mTex.use_map_alpha = True
        mTex.diffuse_color_factor = 0
        mTex.alpha_factor = -1
        bpy.context.space_data.show_backface_culling = False
        return {'FINISHED'}
class cl33(bpy.types.Operator):
    bl_idname =i_0[104]
    bl_label =i_0[105]
    bl_description =i_0[106]
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        layerType = "Glow"
        texCol = 0.0
        texOpas = 0.0
        alphaChoice = True
        normalChoice = False
        mTex = texLayerAdder(layerType, texCol, texOpas, alphaChoice,
        normalChoice)
        mTex.use_map_emit = True
        mTex.emit_factor = 0.05
        mTex.texture.factor_red = 2
        mTex.texture.factor_green = 2
        mTex.texture.factor_blue = 2
        mTex.texture.contrast = 5
        world = scene.world
        ls = world.light_settings
        ls.gather_method = 'APPROXIMATE'
        ls.use_indirect_light = True
        ls.correction = 0.75
        ls.indirect_bounces = 3
        return {'FINISHED'}
class cl34(bpy.types.Operator):
    bl_idname =i_0[107]
    bl_label =i_0[108]
    bl_description =i_0[109]
    def execute(self, context):
        scene = bpy.context.scene
        bt = scene.render.bake_type
        alphaChoice = True
        layerType = "Normal"                    
        normalChoice = True
        texCol = 1
        texOpas = 0
        if 'DISPLACEMENT' in bt:
            layerType = "Displacement"
            normalChoice = False
        if 'DERIVATIVE' in bt:
            layerType = "Derivative"
            normalChoice = True        
        texLayerAdder(layerType, texCol, 
        texOpas, alphaChoice, normalChoice)
        return {'FINISHED'}
class cl35(bpy.types.Operator):
    bl_idname =i_0[110]
    bl_label =i_0[111]
    bl_description =i_0[112]
    def execute(self, context):
        ob = bpy.context.active_object
        userMsg = ''
        for mod in ob.modifiers: 
            if 'Mirror' in mod.name or 'Bevel' in mod.name or 'Shrinkwrap' in mod.name:
                if 'Raise AE' not in mod.name:
                    try:
                        bpy.ops.object.modifier_apply(apply_as='DATA',
                        modifier = mod.name)
                    except:
                        pass
        ob = bpy.context.active_object
        skin = len([mod for mod in ob.modifiers if mod.type == 'SKIN'])
        if skin:
            fu7()
            userMsg = "APPLIED SKIN MODIFIER: Click 'EYE' icon next to"+ob.name+"sBones in the outliner to see it."
        for mod in ob.modifiers:
            if hasattr(mod,'object'):
                if "Bones" not in mod.object.name:
                    userMsg = "Object already has armature. None created for it."
            if mod.type == 'SOLIDIFY':  
                try:              
                    bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)
                    ob.show_x_ray = False
                except:
                    pass
        adaptiveMod = fu25(ob)        
        subsurf = 0
        for mod in ob.modifiers:
            if mod.type == 'SUBSURF':
                if mod != adaptiveMod:
                    subsurf = mod
                    break
        if subsurf: 
            newLevels = subsurf.levels
            bpy.ops.object.modifier_remove(modifier=subsurf.name)
            multires = ob.modifiers.new(name='Multires',type='MULTIRES')
            while newLevels > 0:
                bpy.ops.object.multires_subdivide(modifier=multires.name)
                multires.levels += 1
                newLevels -= 1
        else:
            multires = ob.modifiers.new(name='Multires',type='MULTIRES')
            newLevels = 2
            while newLevels > 0:
                bpy.ops.object.multires_subdivide(modifier=multires.name)
                multires.levels += 1
                newLevels -= 1
        for mod in ob.modifiers:
            try:            
                bpy.ops.object.modifier_move_up(modifier="Multires")
            except:
                pass        
            try: 
                bpy.ops.object.modifier_move_up(modifier="Armature")
            except:
                pass
        bpy.ops.object.shade_smooth()
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.mode_set(mode='SCULPT')
        if userMsg:
            self.report({'INFO'}, userMsg)
        return {'FINISHED'}
def fu25(ob):
    adaptiveMod = 0
    try:
        if ob.cycles.use_adaptive_subdivision:
            for mod in ob.modifiers:
                if mod.type == 'SUBSURF':
                    if mod == ob.modifiers[-1]:
                        adaptiveMod = mod
                        break
    except:
        pass
    return adaptiveMod
class cl36(bpy.types.Operator):
    bl_idname =i_0[113]
    bl_label =i_0[114]
    bl_description =i_0[115]
    def execute(self, context):
        scene = bpy.context.scene
        ob = bpy.context.active_object
        userMsg = ''
        mirror = len([mod for mod in ob.modifiers if mod.type == 'MIRROR'])
        if mirror:
            try:
                bpy.ops.object.modifier_apply(apply_as='DATA', modifier="Mirror")
            except:
                pass
            scene.tool_settings.sculpt.use_symmetry_x = True
        ob = bpy.context.active_object
        skin = len([mod for mod in ob.modifiers if mod.type == 'SKIN'])
        if skin:
            fu7()
            userMsg = "APPLIED SKIN MODIFIER: Click 'EYE' icon next to "+ob.name+"sBones in the outliner to see it."
        adaptiveMod = fu25(ob)          
        for mod in ob.modifiers:
            try:
                if hasattr(mod,'object'):
                    if "Bones" not in type.object.name:
                        userMsg = "Object already has armature. None created for it."
                if mod.type == 'SOLIDIFY':
                    bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)
                    ob.show_x_ray = False
                if mod.type == 'SUBSURF':
                    if mod != adaptiveMod:
                        bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)
                if mod.type == 'MULTIRES':
                    bpy.ops.object.modifier_apply(apply_as='DATA', modifier=mod.name)
            except:
                pass
        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.ops.object.mode_set(mode='SCULPT')
        bpy.ops.sculpt.dynamic_topology_toggle()
        scene.tool_settings.sculpt.detail_type_method = 'CONSTANT'
        scene.tool_settings.sculpt.detail_refine_method = 'SUBDIVIDE_COLLAPSE'
        scene.tool_settings.sculpt.constant_detail = 4.5
        bpy.ops.sculpt.optimize()
        bpy.context.tool_settings.sculpt.brush.auto_smooth_factor = 0.75
        scene.tool_settings.sculpt.use_smooth_shading = True
        bpy.context.tool_settings.sculpt.brush
        for brush in bpy.data.brushes:
            if brush.use_paint_sculpt:
                try:
                    brush.use_accumulate = True
                except:
                    pass
                try:
                    brush.sculpt_plane = 'VIEW'
                except:
                    pass
                try:
                    brush.auto_smooth_factor = 0.1
                except:
                    pass
        if userMsg:
            self.report({'INFO'},userMsg)
        return {'FINISHED'}
class cl37(bpy.types.Operator):
    bl_idname =i_0[116]
    bl_label =i_0[117]
    bl_description =i_0[118]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        ob = bpy.context.active_object
        multires = len([mod for mod in ob.modifiers if mod.type == 'MULTIRES'])
        if multires:
            val = bpy.context.object.modifiers["Multires"].levels
            bpy.context.object.modifiers["Multires"].levels += 1
            bpy.context.object.modifiers["Multires"].sculpt_levels += 1
            bpy.context.object.modifiers["Multires"].render_levels += 1
            val2 = bpy.context.object.modifiers["Multires"].sculpt_levels 
            if val == val2: 
                bpy.ops.object.multires_subdivide(modifier="Multires")
                bpy.context.object.modifiers["Multires"].levels += 1
                val2 = bpy.context.object.modifiers["Multires"].levels
            bpy.context.area.tag_redraw() 
            response = "Subdivision levels: " + str(val2)
            self.report({'INFO'}, response)
        if not multires: 
            bpy.ops.object.zb_multires_add()
        return {'FINISHED'}
class cl37Down(bpy.types.Operator):
    bl_idname =i_0[119]
    bl_label =i_0[120]
    bl_description =i_0[121]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        ob = bpy.context.active_object
        multires = len([mod for mod in ob.modifiers if mod.type == 'MULTIRES'])
        if multires:
            val = bpy.context.object.modifiers["Multires"].levels
            bpy.context.object.modifiers["Multires"].levels -= 1
            bpy.context.object.modifiers["Multires"].sculpt_levels -= 1
            bpy.context.object.modifiers["Multires"].render_levels -= 1
            val2 = bpy.context.object.modifiers["Multires"].sculpt_levels
            bpy.context.area.tag_redraw() 
            response = "Subdivision levels: " + str(val2)
            self.report({'INFO'}, response)
        return {'FINISHED'}
class cl38(bpy.types.Operator):
    bl_idname =i_0[122]
    bl_label =i_0[123]
    bl_description =i_0[124]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        ob = bpy.context.active_object
        multires = len([mod for mod in ob.modifiers if mod.type == 'MULTIRES'])
        if multires:
            lastLevels = ob.modifiers["Multires"].levels
            ob.modifiers["Multires"].sculpt_levels = 0
            bpy.ops.object.multires_higher_levels_delete(modifier="Multires")
            for x in range(lastLevels):
                bpy.ops.object.multires_subdivide(modifier="Multires")
            bpy.context.object.modifiers["Multires"].levels = lastLevels
            bpy.context.object.modifiers["Multires"].sculpt_levels = lastLevels
            bpy.context.object.modifiers["Multires"].render_levels = lastLevels
            bpy.context.area.tag_redraw() 
        return {'FINISHED'}
class cl39(bpy.types.Operator):
    bl_idname =i_0[125]
    bl_label =i_0[126]
    bl_description =i_0[127]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        ob = bpy.context.active_object
        multires = len([mod for mod in ob.modifiers if mod.type == 'MULTIRES'])
        dynamic = bpy.context.active_object.use_dynamic_topology_sculpting
        if multires:
            bpy.ops.object.mode_set(mode='OBJECT')
            try:
                bpy.ops.object.modifier_apply(apply_as='DATA', modifier="Multires")
            except:
                pass
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.remove_doubles()
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.particle_system_remove()
            bpy.ops.object.mode_set(mode='SCULPT')
        if dynamic:
            bpy.ops.sculpt.optimize()
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.remove_doubles()
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.particle_system_remove()
            bpy.ops.object.mode_set(mode='SCULPT')
            self.report({'INFO'}, "Recommend retopology as next step in design")
        return {'FINISHED'}
class cl40(bpy.types.Operator):
    bl_idname =i_0[128]
    bl_label =i_0[129]
    bl_description =i_0[130]
    bl_options = {'REGISTER', 'UNDO'}
    def execute(self, context):
        wm = bpy.context.window_manager
        scene = bpy.context.scene
        sd = bpy.context.space_data
        mode = bpy.context.mode
        ob = bpy.context.active_object
        bt = scene.render.bake_type
        bpy.ops.object.mode_set(mode='OBJECT')
        for obj in bpy.context.selected_objects:
            if ob == obj:
                obj.select = True
            else:
                obj.select = False
        fastModeState = False
        if scene.zbFastMode:
            fastModeState = True
            scene.zbFastMode = False
        fu18()        
        bpy.ops.object.mode_set(mode='OBJECT')        
        modsToAvoid = ['MULTIRES','SUBSURF']
        multires = 0
        for mod in ob.modifiers:
            if mod.type == 'MULTIRES':
                multires = mod
            if mod.type not in modsToAvoid:
                try:
                    bpy.ops.object.modifier_apply(modifier=mod.name,
                    apply_as='DATA')
                except:
                    pass
        if multires == 0:
            try:
                multires = ob.modifiers.new(name='Multires',type='MULTIRES')
            except:
                pass
        if multires == 0:
            print('Multires modifier could not be added to',ob.name)
            print('Aborted bake')
        else:
            if bt != 'DISPLACEMENT' and bt != 'DERIVATIVE':
                if not ob.active_material:
                    bpy.ops.object.zb_paint_color()
            bpy.ops.object.zb_paint_normal()
            mat = ob.active_material
            tex = mat.active_texture
            if bt != 'DISPLACEMENT' and bt != 'DERIVATIVE':
                for i in range(16):
                    bpy.ops.object.zb_move_texture(tex_move_up=1)
                tex.use_normal_map = True
                mat.texture_slots[tex.name].normal_factor = 5
            if bt == 'DERIVATIVE':
                mat.texture_slots[tex.name].normal_factor = .4
            mat.texture_slots[tex.name].use_map_color_diffuse = False        
            fu18()
            levels = multires.levels
            reduced = int(levels/2)
            if reduced < 1:
                reduced = 1
            multires.levels = reduced
            scene.render.bake_margin = 25
            if bt != 'DISPLACEMENT' and bt != 'DERIVATIVE':
                scene.render.bake_type = 'NORMALS'
            scene.render.use_bake_multires = True
            scene.render.use_bake_selected_to_active = False
            bpy.ops.object.bake_image()
            if bt != 'DISPLACEMENT' and bt != 'DERIVATIVE':
                fu21(mat)
            try: 
                multires.levels = levels
            except:
                pass
            fu1(mode)
            if fastModeState:
                scene.zbFastMode = True 
        return {'FINISHED'}
class cl41(bpy.types.Operator):
    bl_idname =i_0[131]
    bl_label =i_0[132]
    bl_description =i_0[133]
    bl_options = {'REGISTER', 'UNDO'}
    option = bpy.props.StringProperty()
    def execute(self, context):
        option = self.option
        scene = bpy.context.scene
        ob = bpy.context.active_object
        if option == 'NEW':
            par = str(len(ob.particle_systems))
            parSys = ob.name + "Strands" + par
            bpy.ops.object.particle_system_add()
            activeSys = ob.particle_systems.active
            activeSys.settings.name = parSys
            set = activeSys.settings
            set.type = 'HAIR'
            set.hair_length = 0.15
            set.count = 0            
            set.adaptive_angle = 3
            set.use_strand_primitive = True
            set.use_hair_bspline = False
            set.render_step = 6
            set.draw_step = 4
            set.cycles.root_width = 0.25
            set.child_type = 'SIMPLE'    
            bpy.ops.object.mode_set(mode='PARTICLE_EDIT')
            set.child_nbr = 65
            set.rendered_child_count = 65
            set.child_length = 1
            set.child_radius = 0.10
            set.roughness_2 = 0.01
            set.draw_percentage = 5
            pe = scene.tool_settings.particle_edit
            pe.show_particles = True
            pe.draw_step = 3
            pe.tool = 'ADD'
            pe.brush.size = 30
            pe.brush.count = 3
            activeSys.use_hair_dynamics = True
            cloth = ob.particle_systems.active.cloth
            settings = cloth.settings
            settings.pin_stiffness = 4
            settings.mass = 0.25
            settings.bending_stiffness = 0.125
            settings.bending_damping = 0.125
            settings.internal_friction = 0
            settings.air_damping = 0.75
            settings.quality = 4
            activeSys.use_hair_dynamics = False
            pe.draw_step = 4
            lastBrush = pe.tool        
            bItems = ['COMB','SMOOTH','LENGTH','PUFF','CUT','WEIGHT']
            for item in bItems:
                pe.tool = item            
                if pe.brush.strength > 5:
                    pe.brush.strength = 0.75
            pe.tool = lastBrush    
        if option == 'COPY':
            renEn = scene.render.engine
            ob = bpy.context.active_object
            parSys = ob.particle_systems.active
            set = parSys.settings        
            lastSetName = set.name
            lastSysName = parSys.name
            copyPar = bpy.data.particles[set.name].copy()                        
            copyPar.name = lastSetName + '_COPY'            
            bpy.ops.object.particle_system_add()
            activeSys = ob.particle_systems.active                
            activeSys.name = lastSysName + '_COPY'        
            activeSys.settings = copyPar
            pe = scene.tool_settings.particle_edit
            pe.tool = 'ADD'
            for sys in bpy.data.particles:
                if sys.users == 0:
                    try:
                        bpy.data.particles.remove(sys, do_unlink = True) 
                    except:
                        bpy.data.particles.remove(sys) 
        if option == 'CHANGE_COLOR':
            renEn = scene.render.engine
            ob = bpy.context.active_object
            parSys = ob.particle_systems.active
            set = parSys.settings
            matName = set.material_slot
            mat = bpy.data.materials[matName]                
            nodes = mat.node_tree.nodes 
            if nodes: 
                if 'Hair BSDF' in nodes:                          
                    hairNode = nodes['Hair BSDF']                
                    if renEn == 'CYCLES':               
                        mCol = hairNode.inputs['Color'].default_value
                        mat.diffuse_color = mCol[0], mCol[1], mCol[2]
                        mat.use_nodes = True            
                    else:                
                        mCol = mat.diffuse_color
                        hairNode.inputs['Color'].default_value = mCol[0],mCol[1],mCol[2], 1
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.mode_set(mode='PARTICLE_EDIT')            
        if option == 'ADD_BASIC_MATERIAL':
            renEn = scene.render.engine
            ob = bpy.context.active_object
            parSys = ob.particle_systems.active
            set = parSys.settings
            baseColor = (0.344312, 0.202204, 0.0661491)
            newMat = bpy.data.materials.new(name = ob.name + 'Hair')
            newMat.diffuse_color = baseColor
            newMat.strand.root_size = 0.5
            newMat.strand.tip_size = 0.25
            newMat.strand.use_tangent_shading = True
            newMat.translucency = 0.1            
            newMat.use_transparency = True
            newMat.alpha = 0.595
            rm = newMat.raytrace_mirror
            rm.use = True
            rm.reflect_factor = 0.5
            rm.fresnel = 4.25
            rm.fresnel_factor = 4.5
            rm.depth = 1
            mat = newMat
            newMat.use_nodes = True            
            mat.node_tree.nodes.clear()
            nodeOutput = mat.node_tree.nodes.new(type = 'ShaderNodeOutputMaterial')
            nodeOutput.location = (200,0)
            nodeHair = mat.node_tree.nodes.new(type = 'ShaderNodeBsdfHair')
            nodeHair.inputs['Color'].default_value = baseColor[0],baseColor[1],baseColor[2], 1
            links = mat.node_tree.links            
            links.new(nodeHair.outputs['BSDF'], nodeOutput.inputs['Surface'])
            if renEn == 'CYCLES':
                newMat.use_nodes = True
            else:
                newMat.use_nodes = False
            if len(ob.data.materials) == 0:
                if len(ob.material_slots) == 0:
                    bpy.ops.object.material_slot_add()            
            if newMat.name not in ob.data.materials:
                ob.data.materials.append(newMat)                        
            set.material_slot = newMat.name                                                    
            bpy.ops.object.mode_set(mode='OBJECT')
            bpy.ops.object.mode_set(mode='PARTICLE_EDIT')    
        return {'FINISHED'}
def zbAutoGPURender(scene,context):    
    scene = bpy.context.scene
    userPref = bpy.context.user_preferences
    system = userPref.system
    props = system.bl_rna.properties
    availableTypes = props['compute_device_type'].enum_items.keys()
    if scene.zbAutoGPURender:
        if system.compute_device_type == 'NONE' or scene.cycles.device == 'CPU':
            if len(availableTypes) > 1:
                deviceType = 'NONE'
                for deviceType in availableTypes:
                    if 'CUDA' in deviceType:
                        system.compute_device_type = deviceType
                        break
                    if deviceType != 'NONE':
                        system.compute_device_type = deviceType
                        break
                if deviceType != 'NONE':    
                    availableDevices = props['compute_device'].enum_items.keys()
                    multi_device = []
                    normal_device = []
                    for device in availableDevices:        
                        if 'MULTI' in device:
                            multi_device.append(device)
                        else:
                            normal_device.append(device)
                    if multi_device:
                        multi = []
                        for d in multi_device:
                            if d.isdigit():
                                multi.append(int(d))        
                        if multi:
                            maxMulti = max(multi)            
                            for device in multi_device:
                                if str(maxMulti) in device:
                                    system.compute_device = device
                                    break
                        else:
                            system.compute_device = multi_device[0]
                    if normal_device:
                        normal = []
                        for d in normal_device:
                            if d.isdigit():
                                normal.append(int(d))          
                        if normal:    
                            maxNormal = max(normal)      
                            for device in normal_device:
                                if str(maxNormal) in device:
                                    system.compute_device = device
                                    break        
                        else:
                            system.compute_device = normal_device[0]    
                    scene.cycles.device = 'GPU'    
    else:
        scene.cycles.device = 'CPU'
def fu26(self,context):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    re = scene.render.engine
    mode = bpy.context.mode
    try:
        bpy.ops.object.mode_set(mode='OBJECT')
        ob = bpy.context.active_object
        mat = ob.active_material
        aTex = mat.active_texture.name
    except:    
        pass
    if scene.zbGoCycles:
        scene.render.engine = 'CYCLES'
        if bpy.context.screen.name in {'Hacker', 'Blender', 'Shader'}:
            world = scene.world
            world.light_settings.ao_factor = 0
            try: 
                bpy.data.worlds['ZB Quick Lights'].ao_factor = 1
            except:
                pass
            if bpy.context.screen.name == 'Shader':
                for area in bpy.context.screen.areas:
                    if area.type == 'VIEW_3D':
                        area.spaces.active.viewport_shade = 'MATERIAL'
        if scene.zbAutoConvertLamps:
            for lamp in bpy.data.lamps:
                lamp.use_nodes = True
        else:
            try:
                bpy.data.objects['-Scene Light'].hide_render = True
                bpy.data.objects['-Shadows'].hide_render = True
            except:
                pass
        if scene.zbAutoConvertCycles:
            try:
                sel = bpy.context.selected_objects
                activeOb = bpy.context.active_object
            except:
                sel = 0
                activeOb = 0
            for ob in bpy.data.objects:
                try:            
                    if ob.type == 'MESH':
                        if ob.hide == False:
                            if 'sf_material_library' not in ob.name:
                                for obj in bpy.context.selected_objects:
                                    obj.select = False
                                ob.select = True
                                bpy.context.scene.objects.active = ob
                                if ob.active_material:
                                    mat = ob.active_material
                                    oldMatTs = []
                                    oldMatTextures = []
                                    for ts in mat.texture_slots:
                                        try:
                                            if ts is not None:
                                                if ts.texture_coords == 'UV':
                                                    if ts.texture is not None:
                                                        if ts.texture.image:
                                                            oldMatTs.append(ts)
                                                            oldMatTextures.append(ts.texture)
                                        except:
                                            pass
                                    if len(oldMatTs) > 0:
                                        texNodes = False
                                        try:
                                            if mat.node_tree is not None:
                                                for node in mat.node_tree.nodes:
                                                    if 'TEX_IMAGE' in node.type:
                                                        texNodes = True
                                                        break
                                            if texNodes == False:
                                                print('Found nodes, but none that work for painting')
                                                mat.node_tree.nodes.clear()
                                        except:
                                            pass
                                        if texNodes == False:
                                            print('Found paint layers but no Cycles support')
                                            for ts in oldMatTs:
                                                doOnce = True
                                                oldImage = bpy.data.images[ts.texture.image.name]
                                                oldTexName = ts.texture.name
                                                if ts.use_map_color_diffuse:
                                                    if ts.use_map_alpha == False:
                                                        if ts.use_map_emit == False:
                                                            doOnce = False
                                                            if 'color' not in oldImage.name.lower():
                                                                oldImage.name += 'Color'
                                                            bpy.ops.object.zb_paint_color()
                                                            mat.active_texture.image = oldImage
                                                            mat.node_tree.nodes['Image Texture zbColor'].image = oldImage
                                                if doOnce:
                                                    if ts.use_map_normal:
                                                        if ts.use_map_color_diffuse == False:
                                                            doOnce = False
                                                            if 'bump' not in oldImage.name.lower():
                                                                oldImage.name += 'Bump'
                                                            bpy.ops.object.zb_paint_bump()
                                                            mat.active_texture.image = oldImage
                                                            mat.node_tree.nodes['Image Texture zbBump'].image = oldImage
                                                if doOnce:
                                                    if ts.use_map_color_spec:
                                                        doOnce = False
                                                        if 'specular' not in oldImage.name.lower():
                                                            oldImage.name += 'Specular'
                                                        bpy.ops.object.zb_paint_specular()
                                                        mat.active_texture.image = oldImage
                                                        mat.node_tree.nodes['Image Texture zbSpecular'].image = oldImage
                                                if doOnce:
                                                    if ts.use_map_emit:
                                                        doOnce = False
                                                        if 'glow' not in oldImage.name.lower():
                                                            oldImage.name += 'Glow'
                                                        bpy.ops.object.zb_paint_glow()
                                                        mat.active_texture.image = oldImage
                                                        mat.node_tree.nodes['Image Texture zbGlow'].image = oldImage
                                                if doOnce:
                                                    if ts.use_map_alpha:
                                                        doOnce = False
                                                        if 'mask' in ts.texture.name.lower():
                                                            if 'alpha_mask' not in oldImage.name.lower():
                                                                oldImage.name += 'Alpha_Mask'
                                                            bpy.ops.object.zb_alpha_mask()
                                                            mat.node_tree.nodes['Image Texture zbAlpha_Mask'].image = oldImage
                                                        else:
                                                            if 'transparent' not in oldImage.name.lower():
                                                                oldImage.name += 'Transparent'
                                                            bpy.ops.object.zb_paint_transparent()
                                                            mat.node_tree.nodes['Image Texture zbColor'].image = oldImage
                                                        mat.active_texture.image = oldImage
                                                if doOnce == False:
                                                    ts.texture = None
                                                    mat.active_texture.name = oldTexName
                                            newSlot = 0 
                                            for ts in mat.texture_slots:
                                                try:
                                                    if ts is not None:
                                                        if ts.texture == bpy.data.textures[aTex]:
                                                            break
                                                    newSlot += 1
                                                except:
                                                    pass
                                            mat.active_texture_index = newSlot
                                            fu0() 
                                            bpy.ops.object.mode_set(mode='OBJECT')
                except:
                    pass
            if sel:
                for obj in bpy.context.selected_objects:
                    obj.select = False
                for ob in sel:
                    ob.select = True
            if activeOb:
                activeOb.select = True
                bpy.context.scene.objects.active = activeOb
            fu1(mode)
        try: 
            if scene.zbQuickLights:
                scene.world = bpy.data.worlds["ZB Quick Lights"]
        except:
            pass
        for mat in bpy.data.materials:
            try:
                nodes = mat.node_tree.nodes                
                for node in nodes:
                    if node.type == 'OUTPUT_MATERIAL':                        
                        mat.use_nodes = True
                        break
            except:
                pass
        for world in bpy.data.worlds:            
            world.use_nodes = True
    else:
        scene.render.engine = 'BLENDER_RENDER'
        if bpy.context.screen.name in {'Hacker', 'Blender', 'Shader'}:
            world = scene.world
            world.light_settings.ao_factor = 1
            try: 
                bpy.data.worlds['ZB Quick Lights'].ao_factor = 1
            except:
                pass
            if bpy.context.screen.name == 'Shader':
                for area in bpy.context.screen.areas:
                    if area.type == 'VIEW_3D':
                        area.spaces.active.viewport_shade = 'MATERIAL'
        if scene.zbQuickLights == True:
            try:
                lastWorld = scene.zbLastWorld
                scene.world = bpy.data.worlds[lastWorld]
            except:
                pass
        for mat in bpy.data.materials:
            if hasattr(mat.node_tree,'nodes'):
                if 'Material Output' in mat.node_tree.nodes:                    
                    for ts in mat.texture_slots:
                        if hasattr(ts,'texture'):
                            if ts.texture:
                                if hasattr(ts.texture,'image'):
                                    mat.use_nodes = False
                                    break
        try: 
            scnLight = bpy.data.objects['-Scene Light']
            scnLight.hide_render = False
            shadows = bpy.data.objects['-Shadows']
            shadows.hide_render = False
        except:
            pass
    scene.update()
    try: 
        if len(scene.sfCFocus) > 0:
            for ob in bpy.data.objects:
                if ob.type == 'CAMERA':
                    cam = ob
                    break
            scene.sfCFocus = cam.data.dof_object.name
        world = scene.world
        if world.mist_settings.use_mist:
            bpy.ops.object.sf_cam_options(func="mist")
    except:
        pass
    scene.update()
    fu1(mode)
    fu11()
class cl42(bpy.types.Operator):
    bl_idname =i_0[134]
    bl_label =i_0[135]
    def execute(self,context):
        brush = bpy.context.tool_settings.sculpt.brush
        m = 'NORMAL'
        try:
            if brush.stroke_method != 'LINE':
                m = 'SMOOTH'
            bpy.ops.sculpt.brush_stroke('INVOKE_DEFAULT', mode=m)
        except:
            pass
        return{'FINISHED'}
class cl43(bpy.types.Operator):
    bl_idname =i_0[136]
    bl_label =i_0[137]
    def modal(self, context, event):
        if event.value == 'RELEASE':
            brush = bpy.context.tool_settings.sculpt.brush
            try:
                brush.direction = 'ADD'
            except:
                try:
                    brush.direction = 'INFLATE'
                except:
                    pass
                pass
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
    def invoke(self, context, event):
        brush = bpy.context.tool_settings.sculpt.brush
        if brush.stroke_method == 'LINE':
            context.window_manager.modal_handler_add(self)
            try:
                brush.direction = 'SUBTRACT'
            except:
                try:
                    brush.direction = 'DEFLATE'
                except:
                    pass
                pass
            bpy.ops.sculpt.brush_stroke('INVOKE_DEFAULT')
        else:
            bpy.ops.sculpt.brush_stroke('INVOKE_DEFAULT',
            mode='INVERT')
            return {'FINISHED'}
        return {'RUNNING_MODAL'}
class cl44(bpy.types.Operator):
    bl_idname =i_0[138]
    bl_label =i_0[139]
    bl_description =i_0[140]
    shapeTool = bpy.props.StringProperty()
    lastBrush = bpy.props.StringProperty()
    def execute(self,context):
        aType = bpy.context.area.type
        sd = bpy.context.space_data
        paint = bpy.context.mode.startswith('PAINT_TEXTURE')
        weight = bpy.context.mode.startswith('PAINT_WEIGHT')
        vertex = bpy.context.mode.startswith('PAINT_VERTEX')
        sculpt = bpy.context.mode.startswith('SCULPT')
        if paint or aType == 'IMAGE_EDITOR':
            type = bpy.context.tool_settings.image_paint
            try:
                brush = bpy.context.tool_settings.image_paint.brush
                if brush.image_tool != 'MASK':
                    if sd.viewport_shade == 'SOLID':
                        sd.viewport_shade = 'MATERIAL'
            except:
                pass
        if sculpt:
            type = bpy.context.tool_settings.sculpt
        if weight:
            type = bpy.context.tool_settings.weight_paint
        if vertex:
            type = bpy.context.tool_settings.vertex_paint
        if paint or aType == 'IMAGE_EDITOR':
            try:
                if brush.use_gradient:
                    if type.brush.name == 'Fill':
                        if self.shapeTool == 'SPACE':
                            type.brush = bpy.data.brushes['Draw']
                            type.brush.use_gradient = True
                    if self.shapeTool == 'LINE':
                        type.brush = bpy.data.brushes['Fill']
                        type.brush.use_gradient = True
                        type.brush.gradient_fill_mode = 'LINEAR'
                    if self.shapeTool == 'ANCHORED':
                        self.shapeTool = 'LINE'
                        type.brush = bpy.data.brushes['Fill']
                        type.brush.use_gradient = True
                        type.brush.gradient_fill_mode = 'RADIAL'
            except:
                pass
            if self.shapeTool == 'SPACE':
                type.input_samples = 3
            else:
                type.input_samples = 1
        if type.brush.texture:
            if self.shapeTool == 'SPACE':
                self.shapeTool = 'DOTS'
        if 'Decal' in type.brush.name:
            if self.shapeTool == 'DOTS':
                self.shapeTool = 'DRAG_DOT'
        type.brush.stroke_method = self.shapeTool
        return{'FINISHED'}
class cl45(bpy.types.Operator):
    bl_idname =i_0[141]
    bl_label =i_0[142]
    bl_description =i_0[143]
    def execute(self,context):
        bpy.ops.brush.stencil_reset_transform()
        bpy.ops.brush.stencil_fit_image_aspect()
        area = bpy.context.area
        x = area.width / 2
        y = area.height / 2
        try:
            if bpy.context.sculpt_object:
                brushName = bpy.context.tool_settings.sculpt.brush.name
            else:
                brushName = bpy.context.tool_settings.image_paint.brush.name
            brush = bpy.data.brushes[brushName]
            brush.stencil_pos.xy = x, y
            brush.texture_slot.scale.xyz = 1
        except:
                pass
        return{'FINISHED'}
class cl46(bpy.types.Operator):
    bl_idname =i_0[144]
    bl_label =i_0[145]
    bl_description = "Sync position, angle and scale of\
 texture brush and texture mask stencils"
    def execute(self,context):
        brush = bpy.context.tool_settings.image_paint.brush
        slot = brush.texture_slot
        mask = brush.mask_texture_slot
        mask.mask_map_mode = 'STENCIL'
        brush.mask_stencil_pos = brush.stencil_pos
        brush.mask_stencil_dimension = brush.stencil_dimension
        mask.offset.xyz = slot.offset.xyz
        mask.scale.xyz = slot.scale.xyz
        mask.angle = slot.angle
        return{'FINISHED'}
def zbGradientSwitch(self,context):
    wm = bpy.context.window_manager
    ts = bpy.context.tool_settings
    paint = ts.image_paint
    if self.zbGradientSwitch:
        try:
            wm.zbBeforeGradBrush = paint.brush.name
            paint.brush = bpy.data.brushes['Fill']
        except:
            pass
        paint.brush.use_gradient = True
    else:
        try:
            if paint.brush.name != 'Draw':
                paint.brush = bpy.data.brushes[wm.zbBeforeGradBrush]
        except:
            pass
        paint.brush.use_gradient = False
def fu27(panel, context, layout, brush, settings, projpaint=False):
    capabilities = brush.image_paint_capabilities
    sd = bpy.context.space_data
    try:
        shade = sd.viewport_shade
    except:
        pass
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    aType = bpy.context.area.type
    toolsettings = context.tool_settings
    ipaint = toolsettings.image_paint
    col = layout.column(align=True)
    if capabilities.has_radius:
        row = col.row(align=True)
        row.operator('object.sf_tn', text='',icon='BLANK1')
        panel.prop_unified_size(row, context, brush, "size", slider=True, text="Radius")
        panel.prop_unified_size(row, context, brush, "use_pressure_size")
    row = col.row(align=True)
    if capabilities.has_space_attenuation:
        row.prop(brush, "use_space_attenuation", toggle=True, icon_only=True)
    else:
        row.operator('object.sf_tn', text='',icon='BLANK1')
    panel.prop_unified_strength(row, context, brush, "strength", text="Strength")
    panel.prop_unified_strength(row, context, brush, "use_pressure_strength")
    row = col.row(align=True)
    row.operator('object.sf_tn', text='',icon='BLANK1')
    row.prop(brush, "zb_hardness", text='Hardness')
    row.operator('object.sf_tn', text='',icon='BLANK1')
    if brush.image_tool == 'SOFTEN':
        col.separator()
        col = layout.column(align=True)
        col.row(align=True).prop(brush, "direction", expand=True)
        col.prop(brush, "sharp_threshold")
        col.prop(brush, "blur_kernel_radius")
    if brush.image_tool == 'CLONE':
        col.separator()
        layout.column(align=True)
        col.prop(settings, "use_clone_layer", text="Clone from paint slot", icon='BRUSH_CLONE')
        if projpaint:
            if settings.use_clone_layer:
                ob = context.active_object
                if len(ob.material_slots) > 1:
                    col.label("Materials")
                    col.template_list("MATERIAL_UL_matslots", "",
                                      ob, "material_slots",
                                      ob, "active_material_index", rows=2)
                mat = ob.active_material
                if mat:
                    col.template_list("TEXTURE_UL_texpaintslots", "",
                                      mat, "texture_paint_images",
                                      mat, "paint_clone_slot", rows=2)
        else:
            col.prop(brush, "clone_image", text="Image")
            col.prop(brush, "clone_alpha", text="Alpha")
    if brush.image_tool == 'FILL':
        row = col.row(align=True)
        row.operator('object.sf_tn', text='',icon='BLANK1')
        row.prop(brush, "fill_threshold", text='Threshold', slider=True)
        row.operator('object.sf_tn', text='',icon='BLANK1')
    if bpy.context.mode == 'PAINT_VERTEX':
        brush = bpy.context.tool_settings.vertex_paint.brush
    else:
        brush = bpy.context.tool_settings.image_paint.brush
    row = col.separator()
    row = col.row(align=True)
    row.label("Brush Stroke")
    row.operator("object.zb_stroke_buttons",
    text ="", icon='MOD_DYNAMICPAINT').shapeTool = 'SPACE'
    row.operator("object.zb_stroke_buttons", text='',
    icon='MOD_CURVE').shapeTool = 'CURVE'
    row.operator("object.zb_stroke_buttons",
    text ="", icon='IPO_LINEAR').shapeTool = 'LINE'
    if not bpy.context.mode.startswith('PAINT_VERTEX'):
        row.operator("object.zb_stroke_buttons",
        text ="", icon='PROP_ON').shapeTool = 'ANCHORED'
    if brush.stroke_method == 'LINE':
        row = col.row(align=True)
        row.label('(Hold alt to constrain line)')
    if brush.stroke_method == 'CURVE':
        row = col.separator()
        row = col.row(align=True)
        row.template_ID(brush, "paint_curve", new="paintcurve.new")
        if brush.paint_curve:
            row = col.separator()
            row = col.row(align=True)
            row.label("(Ctrl-Mouse)")
            row.operator("paintcurve.draw", text="Draw Curve")
        else:
            row = col.row(align=True)
            row.label("(Ctrl-click to make new curve)")
            row = col.row(align=True)
    if not bpy.context.mode.startswith('PAINT_VERTEX'):
        if aType != 'IMAGE_EDITOR':
            try:
                toolsettings = context.tool_settings
                ipaint = toolsettings.image_paint
                row = col.separator()
                row = col.row(align=True)
                row.scale_y = 0.8
                row.label("Mirror")
                row.separator()
                row.prop(ipaint, "use_symmetry_x", text="X", toggle=True)
                row.prop(ipaint, "use_symmetry_y", text="Y", toggle=True)
                row.prop(ipaint, "use_symmetry_z", text="Z", toggle=True)
            except:
                pass
    row = col.separator()
    if brush.image_tool == 'MASK':
        col.prop(brush, "weight", text="Mask Value", slider=True)
        row = col.separator()
        row = col.row(align=True)
        row.prop(ipaint, "invert_stencil", text="Invert", icon='IMAGE_ALPHA')
        if wm.zbViewMaskMode or shade == 'SOLID':
            maskIcon = 'RESTRICT_VIEW_OFF'
        else:
            maskIcon = 'RESTRICT_VIEW_ON'
        row.prop(wm,"zbViewMaskMode", text='View', icon= maskIcon)
        row = col.row(align=True)
        set = scene.tool_settings.image_paint
        row.prop(set, 'use_stencil_layer', text="", icon = 'CANCEL')
        row.operator('image.new', text = 'Reset Mask').gen_context = 'PAINT_STENCIL'
        row = col.separator()
        row = col.row(align=True)
    if brush.image_tool in {'DRAW', 'FILL'}:
        if bpy.context.mode.startswith('PAINT_VERTEX'):
            brush = bpy.context.tool_settings.vertex_paint.brush
        col.separator()
        box = col.box()
        if not brush.use_gradient:
            panel.prop_unified_color_picker(box, context, brush, "color", value_slider=True)
        if brush.use_gradient:
            box.template_color_ramp(brush, "gradient", expand=True)
            if settings.palette:
                sub = box.row(True)
                sub = box.row(True)
                sub.template_palette(settings, "palette", color=True)
            if brush.image_tool == 'DRAW':
                sub = box.row(True)
                sub.prop(wm, "zbHidePaintOptions", text = '', icon = 'COLLAPSEMENU')
                sub = sub.row(align=True)
                sub.scale_x = 0.05
                sub.prop(brush,'color',text='')
                sub = sub.row(align=True)
                sub.scale_x =10
                sub.prop(brush, "gradient_stroke_mode",text="")
                sub.prop(wm,"zbGradientSwitch", text ="Gradient", toggle=True)
                if brush.gradient_stroke_mode in {'SPACING_REPEAT', 'SPACING_CLAMP'}:
                    sub = box.row(True)
                    sub.prop(brush, "grad_spacing")
            elif brush.image_tool == 'FILL':
                sub = box.row(True)
                if bpy.context.mode.startswith('PAINT_VERTEX'):
                    sub.prop(brush, "vertex_tool", text="")
                else:
                    sub.prop(wm, "zbHidePaintOptions", text = '', icon = 'COLLAPSEMENU')
                    sub = sub.row(align=True)
                    sub.scale_x = 0.05
                    sub.prop(brush,'color',text='')
                    sub = sub.row(align=True)
                    sub.scale_x =10
                    sub.prop(brush, "gradient_fill_mode", text="")
                    sub.prop(wm,"zbGradientSwitch", text ="Gradient", toggle=True)
        else:
            if settings.palette:
                sub = box.row(True)
                sub.template_palette(settings, "palette", color=True)
            sub = box.row(True)
            sub.prop(wm, "zbHidePaintOptions", text = '', icon = 'COLLAPSEMENU')
            sub = sub.row(align=True)
            sub.scale_x = 0.05
            sub.prop(brush,'color',text='')
            sub = sub.row(align=True)
            sub.scale_x =10
            if bpy.context.mode.startswith('PAINT_VERTEX'):
                sub.prop(brush, "vertex_tool", text="")
            else:
                sub.prop(brush, "blend", text="")
                sub.prop(wm,"zbGradientSwitch", text ="Gradient", toggle=True)
        if wm.zbHidePaintOptions:
            row = layout.row()
            row.template_ID(settings, "palette", new="palette.new")
            row = layout.row(align=True)
            panel.prop_unified_color(row, context, brush, "color", text="")
            panel.prop_unified_color(row, context, brush, "secondary_color", text="")
            row.operator("paint.brush_colors_flip", icon='FILE_REFRESH', text="")
            col = layout.column(align=True)
            try:
                t = brush.texture
                col.prop(t, 'intensity')
                col.prop(t, 'contrast')
                col.prop(t, 'saturation')
            except:
                pass
            row = layout.row()
            row.prop(settings, "input_samples", text='Stroke Samples')
            row = layout.row(align=True)
            row.label('Curve')
            row.operator("brush.curve_preset", icon='SMOOTHCURVE', text="").shape = 'SMOOTH'
            row.operator("brush.curve_preset", icon='SPHERECURVE', text="").shape = 'ROUND'
            row.operator("brush.curve_preset", icon='ROOTCURVE', text="").shape = 'ROOT'
            row.operator("brush.curve_preset", icon='SHARPCURVE', text="").shape = 'SHARP'
            row.operator("brush.curve_preset", icon='LINCURVE', text="").shape = 'LINE'
            row.operator("brush.curve_preset", icon='NOCURVE', text="").shape = 'MAX'
            row = layout.row()
            row.prop(brush, "use_accumulate")
def fu28(self):
    wm = bpy.context.window_manager
    scene = bpy.context.scene
    context = bpy.context
    layout = self.layout
    aType = bpy.context.area.type
    ts = bpy.context.tool_settings
    try:
        brush = ts.image_paint.brush
        tex_slot = brush.texture_slot
        if context.image_paint_object:
            brush = ts.image_paint.brush
            tex_slot = brush.texture_slot
        if context.vertex_paint_object:
            brush = ts.vertex_paint.brush
            tex_slot = brush.texture_slot
        if context.weight_paint_object:
            brush = ts.weight_paint.brush
            tex_slot = brush.texture_slot
        if context.sculpt_object:
            brush = ts.sculpt.brush
            tex_slot = brush.texture_slot
    except:
        pass
    row = layout.row(align=True)
    row.alignment = 'LEFT'
    row.label('Load')
    row.prop_menu_enum(scene,'zbLoadBrushType', icon='COLLAPSEMENU', text='')
    row.operator('texture.zb_load_brush')
    row.operator('texture.zb_load_brushes')
    row = layout.row()
    showScale = False
    if 'Fill' in brush.name:
        showScale = True
    try:
        if 'Draw' in wm.zbBeforeGradBrush:
            showScale = False
        if 'Graphic Pen' in wm.zbBeforeGradBrush:
            showScale = False
    except:
        pass
    if tex_slot.texture:
        showScale = True
    if showScale:
        row = layout.row(align=True)
        row.prop(tex_slot, "tex_paint_map_mode", text="")
        row.prop(brush,"zb_texscale", text="") 
    if tex_slot.tex_paint_map_mode == 'STENCIL':
        row = layout.row(align=True)
        row.operator("object.zb_center_stencil", text="Center")
        row.operator("object.zb_stencil_sync", text="Sync Mask")
        row = layout.row()
        row.scale_y = 0.5
        row.label("MOVE: Right Mouse")
        row = layout.row()
        row.scale_y = 0.5
        row.label("SCALE: Shift+RMouse")
        row = layout.row()
        row.scale_y = 0.5
        row.label("ROTATE: Ctrl+X")
        row = layout.row()
class BrushButtonsPanel(UnifiedPaintPanel):
    bl_space_type =i_0[146]
    bl_region_type =i_0[147]
    @classmethod
    def poll(cls, context):
        sima = context.space_data
        toolsettings = context.tool_settings.image_paint
        return sima.show_paint and toolsettings.brush
class cl47(bpy.types.Operator):
    bl_idname =i_0[148]
    bl_label =i_0[149]
    bl_description =i_0[150]
    func = bpy.props.StringProperty()
    def execute(self, context):
        func = self.func
        mode = bpy.context.mode
        ob = bpy.context.active_object
        if func == 'to_view':
            bpy.context.space_data.mode = 'VIEW'
            bpy.ops.object.mode_set(mode='EDIT')
        if func == 'to_paint':
            bpy.context.area.type = 'IMAGE_EDITOR'
            if ob.active_material is not None:
                bpy.context.space_data.mode = 'PAINT'
        if func == 'to_image_editor':
            bpy.context.area.type = 'IMAGE_EDITOR'
            try:
                bpy.context.space_data.mode = 'VIEW'
                bpy.ops.object.mode_set(mode='EDIT')
                if mode == 'PAINT_TEXTURE':
                    bpy.context.space_data.mode = 'PAINT'
                bpy.context.space_data.use_realtime_update = True
                tool_shelf = None
                area = bpy.context.area
                for region in area.regions:
                    if region.type == 'TOOLS':
                        tool_shelf = region
                if tool_shelf:
                    if tool_shelf.width < 2:
                        bpy.ops.image.toolshelf()
            except:
                bpy.context.area.type = 'IMAGE_EDITOR'
        func = '' 
        return {'FINISHED'}
class IMAGE_PT_paint(Panel, BrushButtonsPanel):
    bl_label =i_0[151]
    bl_region_type =i_0[152]
    bl_category =i_0[153]
    @classmethod
    def poll(cls, context):
        return bpy.context.area.spaces.active.mode == 'PAINT'
    def draw(self, context):
        wm = bpy.context.window_manager
        layout = self.layout
        settings = context.tool_settings.image_paint
        brush = settings.brush
        col = layout.column()
        sub = col.row(align=True)
        sub.scale_y = 1.4
        sub.scale_x = 1.5
        sub.alignment = 'LEFT'
        sub.operator('object.zb_back_to_3d_view',text='Go Back',icon='FILE_TICK')
        try:
            bpy.context.active_object.active_material.active_texture
            sub.operator('object.zb_image_edit', text='EDIT UVS'
            ,icon='ASSET_MANAGER').func = 'to_view'
        except:
            sub.operator('object.sf_tn', text='EDIT UVS'
            ,icon='ASSET_MANAGER').message = "This object has no uvs to edit"
        col.separator()
        col.template_ID_preview(settings, "brush", new="brush.add", rows=2, cols=6)
        fu28(self)
        fu27(self, context, layout, brush, settings)
class UVToolsPanel:
    bl_space_type =i_0[154]
    bl_region_type =i_0[155]
    bl_category =i_0[156]
    @classmethod
    def poll(cls, context):
        sima = context.space_data
        return sima.show_uvedit and not context.tool_settings.use_uv_sculpt
class cl48(bpy.types.Operator):
    bl_label =i_0[157]
    bl_idname =i_0[158]
    bl_description =i_0[159]
    def execute(self,context):
        if bpy.context.space_data.mode == 'PAINT':
            ob = bpy.context.active_object
            if ob:
                if ob.data.uv_textures:
                    bpy.ops.object.mode_set(mode='TEXTURE_PAINT')
                else:
                    bpy.ops.object.mode_set(mode='OBJECT')
        else:
            bpy.ops.object.mode_set(mode='OBJECT')
        bpy.context.area.type = 'VIEW_3D'
        return{'FINISHED'}
class IMAGE_PT_tools_zbPaintInEditor(Panel,UVToolsPanel):
    bl_label =i_0[160]
    bl_region_type =i_0[161]
    bl_category =i_0[162]
    @classmethod
    def poll(cls, context):
        sima = context.space_data
        return sima.show_uvedit and not context.tool_settings.use_uv_sculpt
    def draw(self, context):
        layout = self.layout
        sub = layout.column()
        sub = sub.row(align=True)
        sub.scale_y = 1.4
        sub.scale_x = 1.5
        sub.alignment = 'LEFT'
        sub.operator('object.zb_back_to_3d_view',text='Go Back',icon='FILE_TICK')
        sub.operator('object.zb_image_edit', text='PAINT UVS'
        ,icon='TPAINT_HLT').func = 'to_paint'
class View3DPaintPanel(UnifiedPaintPanel):
    bl_space_type =i_0[163]
    bl_region_type =i_0[164]
class cl49(Panel, View3DPaintPanel):
    bl_category =i_0[165]
    bl_label =i_0[166]
    bl_region_type =i_0[167]
    @classmethod
    def poll(cls, context):
        return cls.paint_settings(context)
    def draw(self, context):
        scene = bpy.context.scene
        ob = bpy.context.active_object
        layout = self.layout
        toolsettings = context.tool_settings
        settings = self.paint_settings(context)
        brush = settings.brush        
        wm = bpy.context.window_manager
        if not context.particle_edit_object:
            col = layout.split().column()
            col.template_ID_preview(settings, "brush", 
            new="brush.add", rows=3, cols=8)
            fu28(self)
        if context.particle_edit_object:
            tool = settings.tool            
            box = layout.box()
            box.column().prop(settings, "tool", text = 'Brush')
            if tool != 'NONE':                
                if tool != 'WEIGHT':
                    try:
                        sub1 = box.row(True)
                        sub1.scale_x = 0.7
                        sub1.scale_y = 0.8
                        sub1.label('Mirror')
                        sub1.separator()
                        sub1.prop(ob.data, "use_mirror_x", text="X", toggle=True)   
                        text1 = 'Can only x-mirror while in particle mode.'                 
                        sub1.operator('object.sf_tn', text = '   Y').message = text1
                        sub1.operator('object.sf_tn', text = '   Z').message = text1                    
                    except:
                        pass
                col = box.column(True)   
                col.separator()
                set = ob.particle_systems.active.settings
                col.prop(brush, "size", slider=True, text = 'Brush Radius')
                col.prop(brush, "strength", slider=True, text = 'Brush Strength')
            if tool == 'ADD':
                sub = col                 
                sub.prop(brush, "count")
                sub.separator()
                sub.separator()
                sub.prop(settings, "use_default_interpolate",toggle=True)
                sub = sub.column(align=True)
                sub.active = settings.use_default_interpolate
                sub.prop(brush, "steps", slider=True)
                sub.prop(settings, "default_key_count")
            elif tool == 'LENGTH':
                col.separator()
                col.separator()
                col.prop(brush, "length_mode", expand = True)
            elif tool == 'PUFF':
                col.separator()
                col.separator()
                sub = col.row(True)
                sub.prop(brush, "puff_mode", expand=True)
                col.prop(brush, "use_puff_volume", toggle=True)
            if tool != 'NONE':
                col.separator() 
                if set.child_type != 'NONE':                                   
                    col = layout.column()
                    col.separator()
                    col.label('Child Particles')
                    sub = col.column(True)
                    sub.scale_y = 1
                    sub.scale_y = 1.4
                    sub.prop(set, 'draw_percentage', text = 'Display')
                    sub = sub.column(True)
                    sub.scale_y = 1
                    sub = sub.row(True)
                    sub.scale_x = .95
                    sub.scale_y = 0.95
                    sub.operator('object.zb_particle_detail_select', text = '', 
                    icon = 'PARTICLEMODE').detailSelect = 'PARTICLE_EDIT'
                    sub.operator('object.zb_particle_detail_select', text = '', 
                    icon = 'OBJECT_DATAMODE').detailSelect = 'OBJECT'
                    sub.operator('object.zb_particle_detail_select', text = '', 
                    icon = 'RENDER_STILL').detailSelect = 'RENDER'
                    deSel = scene.zbParticleDetailSelect
                    if deSel == 'PARTICLE_EDIT':
                        pEdit = scene.tool_settings.particle_edit
                        sub.prop(pEdit, 'draw_step', text = 'Edit Detail', slider = True)                    
                    if deSel == 'OBJECT':      
                        sys = ob.particle_systems.active.settings                 
                        sub.prop(sys, 'draw_step', text = 'Object Detail', slider = True)                    
                    if deSel == 'RENDER':
                        sys = ob.particle_systems.active.settings
                        sub.prop(sys, 'render_step', text = 'Render Detail', slider = True)                        
                    sub = col.column(True)
                    sub.scale_y = 1
                    sub.prop(set, 'child_radius', text = 'Spread', slider=True)  
                    sub.prop(set, 'clump_factor', text = 'Clump', slider=True)
                    sub.prop(set, 'clump_shape', text = 'Clump Shape', slider=True)
                    sub.prop(set, 'roughness_1', text = 'Roughness', slider=True) 
                    sub.prop(set, 'roughness_endpoint', text = 'Ends', slider=True)    
                    sub.prop(set, 'child_length', text = 'Length', slider=True)  
                    sub.separator()
                    sub.separator()
                    sub.separator()
                    sub.prop(set,'kink', text = '')
                    if set.kink != 'NO':
                        if set.kink == 'SPIRAL':
                            sub.prop(set, 'kink_extra_steps', text ='Detail') 
                            sub1 = sub.row(True)
                            sub1.scale_x = 0.175
                            sub1.prop(set, 'kink_axis', text ='')  
                            sub1 = sub1.row(True)
                            sub1.scale_x = 2
                            sub1.prop(set, 'kink_axis_random', text ='Direction') 
                        sub.separator()                        
                        sub.prop(set, 'kink_frequency', slider=True)
                        sub.prop(set, 'kink_amplitude', text = 'Amplitude', slider=True)                          
                        if set.kink != 'SPIRAL':
                            sub.prop(set, 'kink_amplitude_clump', text = 'Kink Clump', slider=True)  
                            sub.separator()
                        sub.prop(set, 'kink_shape', slider=True) 
                        if set.kink != 'SPIRAL':
                            sub.prop(set, 'kink_flat', text = 'Flatness', slider=True)                
                        sub.prop(set, 'kink_amplitude_random', 
                        text = 'Random', slider=True)
            else:
                col = box.column()
        elif context.sculpt_object and brush:
            capabilities = brush.sculpt_capabilities
            ups = toolsettings.unified_paint_settings
            brushName = bpy.context.tool_settings.sculpt.brush.name
            if 'Decal' in brushName or 'Stencil' in brushName:
                row = layout.row()
                texture = bpy.data.brushes[brushName].texture
                row.prop(texture, "use_color_ramp", text = 'Use As Mask',
                icon = 'MOD_MASK')
            col = layout.column(align=True)
            row = col.row(align=True)
            if ((ups.use_unified_size and ups.use_locked_size) or
                    ((not ups.use_unified_size) and brush.use_locked_size)):
                self.prop_unified_size(row, context, brush, "use_locked_size", icon='LOCKED')
                self.prop_unified_size(row, context, brush, "unprojected_radius", slider=True, text="Radius")
            else:
                self.prop_unified_size(row, context, brush, "use_locked_size", icon='UNLOCKED')
                self.prop_unified_size(row, context, brush, "size", slider=True, text="Radius")
            self.prop_unified_size(row, context, brush, "use_pressure_size")
            try:
                if capabilities.has_strength_pressure:
                    row = col.row(align=True)
                    row.prop(brush, "use_space_attenuation", toggle=True, icon_only=True)
                    self.prop_unified_strength(row, context, brush, "strength", text="Strength")
                    self.prop_unified_strength(row, context, brush, "use_pressure_strength")
                if capabilities.has_auto_smooth:
                    row = col.row(align=True)
                    row.operator('object.sf_tn', text='',icon='BLANK1')
                    row.prop(brush, "auto_smooth_factor", slider=True)
                    row.prop(brush, "use_inverse_smooth_pressure", toggle=True, text="")
            except:
                pass
            row = col.row(align=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            row.prop(brush, "zb_hardness", text='Hardness')
            row.operator('object.sf_tn', text='',icon='BLANK1')
            if capabilities.has_pinch_factor:
                row = col.row(align=True)
                row.operator('object.sf_tn', text='',icon='BLANK1')
                row.prop(brush, "crease_pinch_factor", slider=True, text="Pinch")
                row.operator('object.sf_tn', text='',icon='BLANK1')
            if capabilities.has_normal_weight:
                row = col.row(align=True)
                row.operator('object.sf_tn', text='',icon='BLANK1')
                row.prop(brush, "normal_weight", slider=True)
                row.operator('object.sf_tn', text='',icon='BLANK1')
            if brush.sculpt_tool == 'MASK':
                col.prop(brush, "mask_tool", text="")
            if capabilities.has_height:
                row = col.row(align=True)
                row.operator('object.sf_tn', text='',icon='BLANK1')
                row.prop(brush, "height", slider=True, text="Height")
                row.operator('object.sf_tn', text='',icon='BLANK1')
            if brush.name == 'Mask':
                col.separator()
                if wm.zbViewMaskMode:
                    maskIcon = 'RESTRICT_VIEW_OFF'
                else:
                    maskIcon = 'RESTRICT_VIEW_ON'
                col.prop(wm,"zbViewMaskMode", text='View', icon= maskIcon)
            row = col.separator()
            row = col.row(align=True)
            row.label("Brush Stroke")
            row.operator("object.zb_stroke_buttons",
            text ="", icon='MOD_DYNAMICPAINT').shapeTool = 'SPACE'
            row.operator("object.zb_stroke_buttons", text='',
            icon='MOD_CURVE').shapeTool = 'CURVE'
            row.operator("object.zb_stroke_buttons",
            text ="", icon='IPO_LINEAR').shapeTool = 'LINE'
            if not bpy.context.mode.startswith('PAINT_VERTEX'):
                row.operator("object.zb_stroke_buttons",
                text ="", icon='PROP_ON').shapeTool = 'ANCHORED'
            if brush.stroke_method == 'LINE':
                row = col.row(align=True)
                row.label('(Hold alt to constrain line)')
            if brush.stroke_method == 'CURVE':
                row = col.separator()
                row = col.row(align=True)
                row.template_ID(brush, "paint_curve", new="paintcurve.new")
                if brush.paint_curve:
                    row = col.separator()
                    row = col.row(align=True)
                    row.label("(Ctrl-Mouse)")
                    row.operator("paintcurve.draw", text="Draw Curve")
                else:
                    row = col.row(align=True)
                    row.label("(Ctrl-click to make new curve)")
                row = col.separator()
            row = col.separator()
            row = col.row(align=True)
            sculpt = context.tool_settings.sculpt
            row.scale_y = 0.8
            row.label("Mirror")
            row.separator()
            row.prop(sculpt, "use_symmetry_x", text="X", toggle=True)
            row.prop(sculpt, "use_symmetry_y", text="Y", toggle=True)
            row.prop(sculpt, "use_symmetry_z", text="Z", toggle=True)
            row = col.separator()
            row = col.row()
            row.prop(wm, 'zbHidePaintOptions',
            icon='COLLAPSEMENU', text='More Options',toggle=True)
            if wm.zbHidePaintOptions:
                row = col.separator()
                row = col.row(align=True)
                row.label('Curve')
                row.operator("brush.curve_preset", icon='SMOOTHCURVE', text="").shape = 'SMOOTH'
                row.operator("brush.curve_preset", icon='SPHERECURVE', text="").shape = 'ROUND'
                row.operator("brush.curve_preset", icon='ROOTCURVE', text="").shape = 'ROOT'
                row.operator("brush.curve_preset", icon='SHARPCURVE', text="").shape = 'SHARP'
                row.operator("brush.curve_preset", icon='LINCURVE', text="").shape = 'LINE'
                row.operator("brush.curve_preset", icon='NOCURVE', text="").shape = 'MAX'
                if capabilities.has_sculpt_plane:
                    col.separator()
                    row = col.row()
                    row = col.row(align=True)
                    row.prop(brush, "use_original_normal", toggle=True, icon_only=True)
                    row.prop(brush, "sculpt_plane", text="")
                if capabilities.has_plane_offset:
                    row = col.row(align=True)
                    row.operator('object.sf_tn', text='',icon='BLANK1')
                    row.prop(brush, "plane_offset", slider=True)
                    row.prop(brush, "use_offset_pressure", text="")
                    row = col.row(align=True)
                    row.operator('object.sf_tn', text='',icon='BLANK1')
                    row.prop(brush, "plane_trim", slider=True, text="Distance")
                    row.operator('object.sf_tn', text='',icon='BLANK1')
                    row = col.separator()
                    row = col.row(align=True)
                    row.prop(brush, "use_plane_trim", text="Trim", icon='BLANK1')
                if capabilities.has_persistence:
                    ob = context.sculpt_object
                    do_persistent = True
                    for md in ob.modifiers:
                        if md.type == 'MULTIRES':
                            do_persistent = False
                            break
                    if do_persistent:
                        row = col.row(align=True)
                        row.prop(brush, "use_persistent", icon='BLANK1')
                        row.operator("sculpt.set_persistent_base", text='Set Base')
                col.separator()
                col.row().prop(brush, "direction", expand=True)
                col.separator()
                row = col.row()
                row.prop(brush, "use_frontface", text="Front Faces Only")
                if capabilities.has_accumulate:
                    col.separator()
                    col.prop(brush, "use_accumulate")
        elif context.image_paint_object and brush:
            fu27(self, context, layout, brush, settings, True)
        elif context.weight_paint_object and brush:
            col = layout.column(align=True)
            row = col.row(align=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            self.prop_unified_weight(row, context, brush, "weight", slider=True, text="Weight")
            row.operator('object.sf_tn', text='',icon='BLANK1')
            row = col.row(align=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            self.prop_unified_size(row, context, brush, "size", slider=True, text="Radius")
            self.prop_unified_size(row, context, brush, "use_pressure_size")
            row = col.row(align=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            self.prop_unified_strength(row, context, brush, "strength", text="Strength")
            self.prop_unified_strength(row, context, brush, "use_pressure_strength")
            row = col.row(align=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            row.prop(brush, "zb_hardness", text='Hardness', slider=True)
            row.operator('object.sf_tn', text='',icon='BLANK1')
            row = layout.row()
            row = layout.row()
            row.prop(brush, "vertex_tool", text="")
            col = layout.column()
            col.prop(toolsettings, "use_auto_normalize", text="Auto Normalize")
            col.prop(toolsettings, "use_multipaint", text="Multi-Paint")
            brush = bpy.context.tool_settings.weight_paint.brush
            row = col.separator()
            row = col.row(align=True)
            row.label("Brush Stroke")
            row.operator("object.zb_stroke_buttons",
            text ="", icon='MOD_DYNAMICPAINT').shapeTool = 'SPACE'
            row.operator("object.zb_stroke_buttons", text='',
            icon='MOD_CURVE').shapeTool = 'CURVE'
            row.operator("object.zb_stroke_buttons",
            text ="", icon='IPO_LINEAR').shapeTool = 'LINE'
            if brush.stroke_method == 'LINE':
                row = col.row(align=True)
                row.label('(Hold alt to constrain line)')
            brush = bpy.context.tool_settings.weight_paint.brush
            if brush.stroke_method == 'CURVE':
                row = col.separator()
                row = col.row(align=True)
                row.template_ID(brush, "paint_curve", new="paintcurve.new")
                if brush.paint_curve:
                    row = col.separator()
                    row = col.row(align=True)
                    row.label("(Ctrl-Mouse)")
                    row.operator("paintcurve.draw", text="Draw Curve")
                else:
                    row = col.row(align=True)
                    row.label("(Ctrl-click to make new curve)")
                row = col.separator()
            row = col.row()
            row = col.row()
            row = col.row(align=True)
            row.scale_y = 0.8
            row.label('Mirror')
            row.separator()
            row.prop(scene, "zbWeightMirror", text='X', toggle=True)
            row.operator("object.sf_tn", text='   Y')
            row.operator("object.sf_tn", text='   Z')
            if len(bpy.data.armatures) > 0:
                displayWarning = 0
                try:
                    for mod in ob.modifiers:
                        if mod.type == 'ARMATURE':
                            if mod.object:
                                if mod.object.mode != 'POSE':
                                    displayWarning = 1
                                    col = layout.column(align=True)  
                                    col.separator()
                                    col = layout.column(align=True)                                
                                    col.scale_y = 0.65
                                    col.label('The armature bones can not')
                                    col.separator()  
                                    col.label('be selected from weight')
                                    col.separator()
                                    col.label('paint mode unless the arm-')
                                    col.separator()    
                                    col.label('-ature is set to pose mode.')
                                    col.separator()
                                    col = layout.column(align=True)
                                    col.scale_y = 2
                                    col.prop(wm,'zbMakeBonesSelectable', toggle=True)
                                    break
                except:
                    pass 
                if displayWarning == 0:
                    col = layout.column(align=True)
                    col.separator()
                    col.scale_y = 0.75                    
                    if hasattr(scene,'sfSelectByGroup'):
                        col.label('Ctrl-Click to select bones')
                        col.label('Shift-Ctrl-Click for multiple') 
                    else:
                        if scene.zbWeightMirror:
                            col.label('Ctrl-Click to mirror select bones')
        elif context.vertex_paint_object and brush:
            fu27(self, context, layout, brush, settings, True)
def zbMakeBonesSelectable(self,context):    
    if self.zbMakeBonesSelectable:
        scene = bpy.context.scene    
        ob = bpy.context.active_object
        arm = 0
        if ob:
            if ob.modifiers:
                for mod in ob.modifiers:
                    if mod.type == 'ARMATURE':
                        if mod.object:
                            arm = mod.object
                            break    
        if arm:
            scene.objects.active = arm
            arm.select = True
            bpy.ops.object.mode_set(mode='POSE')
        ob.select = True
        scene.objects.active = ob
        bpy.ops.object.mode_set(mode='WEIGHT_PAINT')
        self.zbMakeBonesSelectable = False
def zbSelectParticleMat(self,context):
    ob = bpy.context.active_object        
    parSys = ob.particle_systems.active
    set = parSys.settings    
    mats = bpy.data.materials   
    newMat = bpy.data.materials[self.zbSelectParticleMat]
    if len(ob.data.materials) < 1:
        if len(ob.material_slots) == 0:
            bpy.ops.object.material_slot_add()
    if newMat.name not in ob.data.materials:        
        ob.data.materials.append(newMat)            
    if set.material_slot != newMat.name:
        set.material_slot = newMat.name
    self.zbSelectParticleMat = ''
class zbPaint(bpy.types.Panel):
    bl_label =i_0[168]
    bl_space_type =i_0[169]
    bl_region_type =i_0[170]
    def draw(self, context):
        wm = context.window_manager
        scene = bpy.context.scene
        sd = bpy.context.space_data
        ob = bpy.context.active_object
        re = scene.render.engine
        mode = bpy.context.mode
        layout = self.layout
        row = layout.row(True)
        row.scale_y = .6
        row.scale_x = 1.75
        row.operator("object.zb_mode_buttons", text="", icon='OBJECT_DATA').modeButton  = 1
        row.operator("object.zb_mode_buttons", text="", icon='SCULPTMODE_HLT').modeButton  = 2
        row.operator("object.zb_mode_buttons", text="", icon='BRUSH_DATA').modeButton  = 3
        row.operator("object.zb_mode_buttons", text="", icon='PARTICLEMODE').modeButton = 4
        sub = row.row(True)
        sub.scale_y = .6
        sub.scale_x = 1.25
        sub.operator("wm.call_menu", text="", icon='BLANK1').name = "view3D.zb_layer_options_menu"
        sub = sub.row(True)
        sub.scale_y = .6
        sub.scale_x = 4
        sub.operator("screen.screen_full_area", text="", icon='FULLSCREEN_ENTER')
        row = layout.row(True)
        if mode == 'PAINT_TEXTURE':
            special= 0
            spacer = 0
            col = layout.column()
            row = layout.row(align=True)
            if ob.active_material:
                n = ob.active_material.name
                if 'ZB Painted' in n or 'ZBA Painted' in n:
                    row.label('Alchemy Mode (locked)',icon = 'BOOKMARKS')
                else:    
                    row.label('Blending Mode')
                    sub = row.row(align=True)
                    sub.scale_x = 0.7
                    sub.prop(scene, "zbGoCycles", icon='NODETREE', text="Cycles")
            col = layout.column(align=True)
            if ob.active_material:
                mat = ob.active_material
                ts = mat.texture_slots[mat.active_texture_index]
                if re != 'CYCLES':
                    if ts: 
                        col.prop(ts,'blend_type',text='', icon = 'POTATO')
                        if ts.use_map_diffuse:
                            spacer += 1
                            col.prop(ts,'diffuse_factor', text = "Color Brightness", slider = True)
                        if ts.use_map_color_diffuse:
                            spacer += 1
                            col.prop(ts,'diffuse_color_factor', text = "Layer Opacity", slider = True)
                        if ts.use_map_translucency:
                            spacer += 1
                            col.prop(ts,'translucency_factor', text = "Translucency", slider = True)
                        if ts.use_map_specular:
                            spacer += 1
                            col.prop(ts,'specular_factor', text = "Specular", slider = True)
                        if ts.use_map_color_spec:
                            spacer += 1
                            col.prop(ts,'specular_color_factor', text = "Shininess", slider = True)
                        if ts.use_map_hardness:
                            spacer += 1
                            col.prop(ts,'hardness_factor', text = "Hardness", slider = True)
                        if ts.use_map_alpha:
                            spacer += 1
                            col.prop(ts,'alpha_factor', text = "Transparency", slider = True)
                        if ts.use_map_normal:
                            try:
                                if ts.texture.use_normal_map:
                                    theText = 'Normal'
                                else:
                                    theText = 'Bumpiness'
                                spacer += 1
                                col.prop(ts,'normal_factor', text = theText, slider = True)
                            except:
                                pass
                        if ts.use_map_warp:
                            spacer += 1
                            col.prop(ts,'warp_factor', text = "Warp", slider = True)
                        if ts.use_map_displacement:
                            spacer += 1
                            col.prop(ts,'displacement_factor', text = "Displacement",  slider = True)
                        if ts.use_map_ambient:
                            spacer += 1
                            col.prop(ts,'ambient_factor', text = "Ambient", slider = True)
                        if ts.use_map_emit:
                            spacer += 1
                            col.prop(ts,'emit_factor', text = "Emit", slider = True)
                        if ts.use_map_mirror:
                            spacer += 1
                            col.prop(ts,'mirror_factor', text = "Mirror", slider = True)
                        if ts.use_map_raymir:
                            spacer += 1
                            col.prop(ts,'raymir_factor', text = "Ray Mirror", slider = True)
                    else:
                        special = 1
                        col.label('Cycles materials not created')
                        col.label('with Zero Brush can not be')
                        col.label('converted to Blender Render')
                        col.label('materials. Adding new layers')
                        col.label('may cause unexpected results.')
                        col.label('')
                else:
                    if ts:
                        name = ts.texture.image.name
                        if "color" in name.lower() or "transparent" in name.lower() or "alpha" in name.lower():
                            if 'specular' not in name.lower():
                                try:
                                    node = mat.node_tree.nodes['Mix zbColor']
                                    col.prop(node, "blend_type", text="", icon='POTATO')
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Mixed1']
                                    col.prop(node.inputs['Fac'], "default_value", text="Reflectivity")
                                    spacer +=1
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Glossy BSDF zbColor']
                                    col.prop(node.inputs['Roughness'], "default_value", text="Roughness")
                                    spacer +=1
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Mixed2']
                                    col.prop(node.inputs['Fac'], "default_value", text="Light Emission")
                                    spacer +=1
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Mixed3']
                                    col.prop(node.inputs['Fac'], "default_value", text="Transparency")
                                    spacer +=1
                                except:
                                    pass
                                col.separator()
                                col.separator()
                                try:
                                    node = mat.node_tree.nodes['Math zbColor']
                                    col.prop(node.inputs[1], "default_value", text="Bumpiness")
                                    spacer +=1
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Bright/Contrast zbColor']
                                    col.prop(node.inputs['Bright'], "default_value", text="Brightness")
                                    spacer +=1
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Bright/Contrast zbColor']
                                    col.prop(node.inputs['Contrast'], "default_value", text="Contrast")
                                    spacer +=1
                                except:
                                    pass
                        if "bump" in name.lower():
                            try:
                                node = mat.node_tree.nodes['Math zbBump']
                                col.prop(node, "operation", text = "", icon="POTATO")
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Math zbBump']
                                col.prop(node.inputs[1],"default_value", text="Bumpiness")
                                spacer +=1
                            except:
                                pass
                            col.separator()
                            col.separator()
                            try:
                                node = mat.node_tree.nodes['Bright/Contrast zbBump']
                                col.prop(node.inputs['Bright'], "default_value", text="Brightness")
                                spacer +=1
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Bright/Contrast zbBump']
                                col.prop(node.inputs['Contrast'], "default_value", text="Contrast")
                                spacer +=1
                            except:
                                pass
                        if "specular" in name.lower():
                            try:
                                node = mat.node_tree.nodes['Mix zbSpecular']
                                col.prop(node, "blend_type", text="", icon='POTATO')
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Glossy BSDF zbSpecular']
                                col.prop(node.inputs['Roughness'], "default_value", text="Roughness")
                                spacer +=1
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Math zbSpecular']
                                col.prop(node.inputs[1], "default_value", text="Shininess")
                                spacer +=1
                            except:
                                pass
                            col.separator()
                            col.separator()
                            try:
                                node = mat.node_tree.nodes['Bright/Contrast zbSpecular']
                                col.prop(node.inputs['Bright'], "default_value", text="Brightness")
                                spacer +=1
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Bright/Contrast zbSpecular']
                                col.prop(node.inputs['Contrast'], "default_value", text="Contrast")
                                spacer +=1
                            except:
                                pass
                        if "glow" in name.lower():
                            try:
                                node = mat.node_tree.nodes['Mix zbGlow']
                                col.prop(node, "blend_type", text="", icon='POTATO')
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Emission zbGlow']
                                col.prop(node.inputs['Strength'], "default_value",text="Strength")
                                spacer +=1
                            except:
                                pass
                            try:
                                node = mat.node_tree.nodes['Math zbGlow']
                                col.prop(node.inputs[1], "default_value",text="Intensity")
                                spacer +=1
                            except:
                                pass
                        if "normal" in name.lower():   
                            if 'bump' not in name.lower():
                                try:
                                    node = mat.node_tree.nodes['Mix zbColor']
                                    col.prop(node, "blend_type", text="", icon='POTATO')
                                except:
                                    pass
                                try:
                                    node = mat.node_tree.nodes['Normal Map zbNormal']
                                    col.prop(node.inputs[0], "default_value", text="Normal")
                                    spacer +=1
                                except:
                                    pass
                if spacer == 0:
                    if re == 'CYCLES':
                        col.label('Layers not created with')
                        col.label('Zero Brush (and even some')  
                        col.label('bake type layers created') 
                        col.label('with Zero Brush) may not')
                        col.label('have any sliders to display.')   
                        col.label('')     
                        col.label('')
                        col.label('')    
                        col.separator()
                        col.separator()
                    else:
                        spc = 32
                        if special == 0:
                            col.separator()
                            col.separator()
                        else:
                            col.separator()
                            col.separator()
                            spc = 8
                        for x in range(spc):
                            row = layout.row()
                if spacer == 1:
                    col.separator()
                    col.separator()
                    for x in range(24):
                        row = layout.row()
                if spacer == 2:
                    col.separator()
                    col.separator()
                    for x in range(20):
                        row = layout.row()
                if spacer == 3:
                    for x in range(16):
                        row = layout.row()
                if spacer == 4:
                    for x in range(12):
                        row = layout.row()
                row = layout.row(align=True)
                row = layout.row(align=True)
                row.scale_y = 1.5
                row.operator("wm.call_menu", icon = "COLLAPSEMENU",text="Options").name = "view3D.zb_layer_options_menu"
                row.prop(wm, "zbPaintThrough", text = "", icon ="TPAINT_HLT")
                if re != 'CYCLES':
                    if mat is not None:
                        row.prop(mat, "use_shadeless", text = "", icon ="TEXTURE_SHADED")
                else:
                    row.prop(scene, "zbQuickLights", text = "", icon ='LAMP_SUN')
                if sd.viewport_shade != 'RENDERED':
                    zbRendIcon = "MATERIAL"
                else:
                    zbRendIcon = "SMOOTH"
                row.operator("object.zb_render_prev", text="", icon = zbRendIcon)
                row.operator("object.zb_reset_uvs", text = "", icon ="FILE_REFRESH")
                row = layout.row()
                if sd.viewport_shade == 'RENDERED':
                    row.scale_y = 0.8
                    row.label('(Ctrl-B set preview border)')
                i = -1 
                for t in mat.texture_slots:
                    i+=1
                    try:
                        if t.texture.type =='IMAGE':
                            row = layout.row(align= True)
                            if t.texture == mat.active_texture:
                                ai =  'BRUSH_DATA'
                            else:
                                ai = 'BLANK1'
                            row.operator('object.zb_set_active_layer',
                                text = "", icon = ai).tex_index =i
                            row.prop(t.texture,'name', text = "")
                            if t.use:
                                ic = 'RESTRICT_VIEW_OFF'
                            else:
                                ic = 'RESTRICT_VIEW_ON'
                            if t.texture == mat.active_texture:
                                if len(mat.texture_slots.items()) > 1:
                                    row.operator("object.zb_move_texture", text = "",icon = "TRIA_UP").tex_move_up = 1
                                    row.operator("object.zb_move_texture", text = "",icon = "TRIA_DOWN").tex_move_down = 1
                                else:
                                    row.operator("object.zb_mode_buttons", text = "",icon = "TRIA_UP").modeButton = 100
                                    row.operator("object.zb_mode_buttons", text = "",icon = "TRIA_DOWN").modeButton = 100
                            row.operator("object.zb_delete_texture", text = "",icon = "X").tex_kill = i
                            if re != 'CYCLES':
                                row.prop(t,'use', text = "",icon = ic)
                            else:
                                row.operator('object.sf_tn',text='',icon='BLANK1')
                    except:
                        pass
                row = layout.row()
                col = layout.column(align = True)
                box = col.box()
                sub = box.column(True)
                sub.operator("object.zb_paint_color", icon='TEXTURE')
                sub.operator("object.zb_paint_bump", icon='TEXTURE')
                sub.operator("object.zb_paint_specular", icon='TEXTURE')
                sub.operator("object.zb_paint_glow", icon='TEXTURE')
                sub = box.column()
                sub = box.column(True)
                sub.operator("object.zb_paint_transparent", icon='TEXTURE')
                sub.operator("object.zb_alpha_mask", icon='TEXTURE')
                sub = box.column()
                sub = box.column(True)
                sub.prop(scene, "zbImgSize")
                sub = sub.row(align=True)
                sub.scale_x = 1.2
                sub.prop(wm,'zbSaveLayerOptions',text='',icon='FILE_FOLDER')
                sub.operator("object.zb_save_layers")
                sub = box.column()
                if wm.zbSaveLayerOptions:
                    sub.scale_y = 0.5
                    sub.label('Save images to a folder')
                    sub.label('instead of internally')
                    sub = box.column()
                    sub.scale_y = 1
                    sub.prop(scene,'zbSaveToHardDrive',
                    text='Save To A Folder')
                    sub.prop(wm, 'zbSaveImagePath',text='')
                    sub = box.column(True)
                    sub = sub.row(align=True)
                    sub.label('as:')
                    sub.prop_enum(wm,"zbSaveType",value = '.PNG')
                    sub.prop_enum(wm,"zbSaveType",value = '.TIFF')
                    sub.prop_enum(wm,"zbSaveType",value = '.TGA')
                    sub.prop_enum(wm,"zbSaveType",value = '.JPEG')
                    sub = box.column()
                    sub = box.column()
                    sub.scale_y = 0.3
                    sub.label('New Layer Width x Height')
                    sub = box.column()
                    sub = sub.row(align=True)
                    sub.prop(scene,'zbImgSize', text = '')
                    sub.prop(scene,'zbImgSizeH',text = '')
                    sub = box.column()
                    sub = sub.row()
                if scene.zbSaveToHardDrive:
                    sub.scale_y = 1.3
                    sub.operator('object.zb_reload_all_images',
                    text='Reload All Images', icon='FILE_REFRESH')
                    sub = box.column()
        if mode.startswith('SCULPT'):
            col = layout.column(align=True)
            col.separator()
            ob = bpy.context.active_object
            multires = len([mod for mod in ob.modifiers if mod.type == 'MULTIRES'])
            dynamic = bpy.context.active_object.use_dynamic_topology_sculpting
            if not multires and not dynamic:
                col.operator("object.zb_multires_add")
                col.operator("object.zb_sculpt_dynamic")
            if multires:
                row = col.row(align = True)
                row.label("Detail")
                row.operator("object.zb_sub_multires", text='more')
                row.operator("object.zb_reset_detail", text='',icon ='FILE_REFRESH')
                row.operator("object.zb_multires_down", text='less')
                row = layout.row(align=True)
                row.operator("object.zb_generate_base_mesh", text="Apply")
                row.operator("object.zb_message", text="As Normal").message = 'NORMALS'
                row = layout.row()
            if dynamic:
                row = col.row(align = True)
                row.operator("object.zb_generate_base_mesh", text="Apply Detail")
                sub = col.row(align=True)
                sub.operator("sculpt.sample_detail_size", text="", icon='EYEDROPPER')
                toolsettings = context.tool_settings
                sculpt = toolsettings.sculpt
                sub.prop(sculpt, "constant_detail")
        if mode.startswith('PARTICLE'):
            ob = context.active_object
            if ob:                
                sys = ob.particle_systems
                if sys:
                    row = layout.row()
                    row = layout.row()
                    row.template_list("PARTICLE_UL_particle_systems", "particle_systems", ob, "particle_systems",
                              ob.particle_systems, "active_index", rows=1, maxrows = 25)
                    if sys.active:
                        col = layout.column()
                        row = col.row(True)
                        row.operator("object.zb_add_strands", text="New").option = 'NEW'
                        row.operator("object.zb_add_strands", text="Copy").option = 'COPY'
                        row.operator("object.particle_system_remove", text="Delete")
                        col = layout.column(True)
                        col.separator()
                        col.label('Layer Options')
                        col.separator()
                        col.prop(sys.active,'use_hair_dynamics', toggle = True,
                        icon = 'PHYSICS', text = 'Animate Strands')  
                        col.separator()
                        col.separator()
                        sub1 = col.row(True)     
                        sub1.scale_x = 0.11      
                        sub1.prop_search(wm, "zbSelectParticleMat", bpy.data, "materials",
                        text = '',icon="MATERIAL_DATA")
                        sub1 = sub1.row(True)
                        sub1.scale_x = 5
                        sub1.operator('object.zb_add_strands', 
                        text = 'Add Basic Material').option = 'ADD_BASIC_MATERIAL'
                        parMat = sys.active.settings.material_slot
                        sub = col.row(True)
                        sub.scale_x = 0.15
                        if parMat in ob.data.materials:                            
                            if len(ob.material_slots) > 1:
                                parMat = bpy.data.materials[parMat]
                                chngCol = True                            
                                if re == 'CYCLES':
                                    if parMat.node_tree.nodes:
                                        try:
                                            nodeHair = parMat.node_tree.nodes['Hair BSDF']
                                            sub.prop(nodeHair.inputs['Color'], 'default_value',
                                            text = '')
                                        except:
                                            chngCol = False
                                else:                                    
                                    if parMat.strand.use_tangent_shading:
                                        sub.prop(parMat, 'diffuse_color',text = '')
                                    else:
                                        chngCol = False
                                if chngCol:
                                    sub = sub.row(True)
                                    sub.scale_x = 2
                                    sub.operator('object.zb_add_strands',
                                    text = 'Apply Color').option = 'CHANGE_COLOR'
                        col.separator()
                        col.separator()
        if mode.startswith('OBJECT'):
            if wm.showBrushLayerOptions:
                for mat in bpy.data.materials:
                    if '_zb_proxy' in mat.name:
                        slot = mat.texture_slots[0]
                        break
                col = layout.column()
                sub = layout.column(align=True)
                sub.scale_y = 1.4
                sub.operator('object.zb_layer_from_brush',
                icon='FILE_TICK',text='Finish Brush Layer').action = 'FINISH'
                sub = sub.column(align=True)
                sub.scale_y = 1
                sub.operator('object.zb_layer_from_brush',
                icon='CANCEL', text='Cancel').action = 'CANCEL'
                row = layout.row()
                row.operator('object.zb_layer_from_brush', text='Re-Apply Brush').action = 'FLIP'
                row = layout.row()
                row.column().prop(slot, "offset", text= 'Position')
                row.column().prop(slot, "scale", text='Scale')
def fu29(self,context):
    scene = bpy.context.scene    
    scene.zbImgSizeH = scene.zbImgSize
    return
class cl50(bpy.types.Operator):
    bl_idname =i_0[171]
    bl_label =i_0[172]
    bl_description =i_0[173]
    message = bpy.props.StringProperty()
    def execute(self, context):
        message = self.message
        if len(message) > 0:
            self.report({'INFO'}, message)
        else:
            self.report({'INFO'}, "This option is not available in this mode")
        pass
        return {'FINISHED'}
def fu30(scene):
    try:
        bpy.ops.object.zb_save_layers(save_only_active=False)
    except:
        pass
class cl51(bpy.types.Operator):
    bl_idname =i_0[174]
    bl_label =i_0[175]
    def execute(self,context):
        scene = bpy.context.scene
        wm = bpy.context.window_manager
        if scene.zbSaveWhenSave:
            bpy.app.handlers.save_pre.append(fu30)
        for map in wm.keyconfigs.addon.keymaps:      
            ki = map.keymap_items                            
            for key in ki:
                if 'ZB Init Listener' in key.name:
                    key.active = False                                         
        return{'FINISHED'}
def zbWeightMirror(self,context):
    scene = bpy.context.scene
    wm = bpy.context.window_manager    
    km = wm.keyconfigs.addon.keymaps['Weight Paint']
    kmi = km.keymap_items["paint.zb_select_weight_mirror"]
    ob = bpy.context.active_object        
    if ob:
        if self.zbWeightMirror:            
            kmi.active = True
            bpy.ops.object.origin_set(type='ORIGIN_CENTER_OF_MASS')        
            bpy.ops.object.mode_set(mode='EDIT')
            bpy.ops.mesh.select_all(action='SELECT')
            bpy.ops.mesh.normals_make_consistent()
            bpy.ops.mesh.symmetry_snap()                        
            bpy.ops.object.mode_set(mode='WEIGHT_PAINT')        
            ob.data.use_mirror_x = True
            ob.data.use_mirror_topology = False
            scene.tool_settings.use_multipaint = True
            if ob.modifiers:
                for mod in ob.modifiers:
                    if mod.type == 'ARMATURE':
                        if mod.object:
                            arm = mod.object.data                            
                            activeBone = arm.bones.active
                            mirrorBone = ''
                            if activeBone:
                                if '.l' in activeBone.name:
                                    mirrorBone = activeBone.name.replace('.l','.r')
                                if '.r' in activeBone.name:
                                    mirrorBone = activeBone.name.replace('.r','.l')
                            if mirrorBone:
                                arm.bones[mirrorBone].select = True                                                               
                        break
        else:            
            kmi.active = False
            ob.data.use_mirror_x = False
            ob.data.use_mirror_topology = False
            scene.tool_settings.use_multipaint = False
class cl52(bpy.types.Operator):
    bl_idname =i_0[176]
    bl_label =i_0[177]
    def execute(self,context):            
        scene = bpy.context.scene        
        bpy.ops.view3d.select('INVOKE_DEFAULT')
        ob = bpy.context.active_object
        if ob.modifiers:
            for mod in ob.modifiers:
                if mod.type == 'ARMATURE':
                    if mod.object:
                        arm = mod.object.data                            
                        activeBone = arm.bones.active
                        mirrorBone = ''
                        if activeBone:
                            if '.l' in activeBone.name:
                                mirrorBone = activeBone.name.replace('.l','.r')
                            if '.r' in activeBone.name:
                                mirrorBone = activeBone.name.replace('.r','.l')
                        if mirrorBone:
                            arm.bones[mirrorBone].select = True                                                               
                    break                
        if scene.tool_settings.use_multipaint:
            scene.tool_settings.use_multipaint = True        
        return{'FINISHED'}
def fu31(self,context):
    aType = bpy.context.area.type
    toolSet = bpy.context.tool_settings 
    mode = bpy.context.mode
    if mode == 'PAINT_TEXTURE' or aType == 'IMAGE_EDITOR':
        brush = toolSet.image_paint.brush
    if mode == 'SCULPT':
        brush = toolSet.sculpt.brush
    if mode == 'PAINT_WEIGHT':
        brush = toolSet.weight_paint.brush
    if mode == 'PAINT_VERTEX':
        brush = toolSet.vertex_paint.brush    
    val = float(brush.zb_hardness/100)
    if val < 0.30:
        val = 0.30
    if val > 0.98:
        val = 0.98
    bpy.ops.brush.curve_preset(shape='LINE')
    bpy.data.brushes[brush.name].curve.curves[0].points.new(val, val)
    bpy.data.brushes[brush.name].curve.update()
def fu32(self,context):
    toolSet = bpy.context.tool_settings    
    if context.image_paint_object:
        brush = toolSet.image_paint.brush
    if context.vertex_paint_object:
        brush = toolSet.vertex_paint.brush
    if context.sculpt_object:
        brush = toolSet.sculpt.brush
    tex = brush.texture_slot
    percent = brush.zb_texscale
    if percent > 97:
        percent = 97    
    percent = 100 - percent
    x = tex.scale[0]
    y = tex.scale[1]
    z = tex.scale[2]    
    if brush.zb_texscale_x == 0:
        brush.zb_texscale_x = x * 3
    if brush.zb_texscale_y == 0:
        brush.zb_texscale_y = y * 3
    if brush.zb_texscale_z == 0:
        brush.zb_texscale_z = z * 3   
    x = brush.zb_texscale_x
    y = brush.zb_texscale_y
    z = brush.zb_texscale_z                
    tex.scale[0] = (percent * x) / 100.0
    tex.scale[1] = (percent * y) / 100.0
    tex.scale[2] = zPer = (percent * z) / 100.0
    brush.mask_texture_slot.scale.xyz = brush.texture_slot.scale.xyz
class cl53(bpy.types.PropertyGroup):
    wm = bpy.types.WindowManager
    scene = bpy.types.Scene    
    txtNote1 = 'Open a new file, adjust these settings, then go to "File" and '
    txtNote2 = 'press "Save Startup File" to keep your changes.'
    txtNote=txtNote1+txtNote2
    bpy.types.Brush.zb_texscale = bpy.props.IntProperty(
    name = 'Brush Scale',
    subtype = 'PERCENTAGE', min = 0, max = 100,
    default = 50,
    description = 'Increase or decrease the overall scale of the texture being used with this brush.',
    update = fu32)
    bpy.types.Brush.zb_texscale_x = bpy.props.IntProperty()
    bpy.types.Brush.zb_texscale_y = bpy.props.IntProperty()
    bpy.types.Brush.zb_texscale_z = bpy.props.IntProperty()
    bpy.types.Brush.zb_hardness = bpy.props.IntProperty(
    name = 'Brush Hardness',
    subtype = 'PERCENTAGE', min = 0, max = 100,
    default = 50,
    description = 'Soften or harden the edge of the brush (controls brush curve)',
    update = fu31)
    txt1 = 'Use user defined bake values from the scene instead of predefined Zero Brush '
    txt2 = 'values. This includes: "Margin", "Distance", "Bias", and "Extrusion" values. '
    txt3 = '"Selected To Active" can still be set via the ZB options menu before baking, shortened to "Sel-To-Active".'
    scene.zbUserBakeSettings = bpy.props.BoolProperty(
    name = 'User Bake Settings',
    default = False,
    description = txt1+txt2+txt3
    )
    txt1 = 'Bake the contents of the first selected object to the active object '
    txt2 = '(the last Shift-selected object). Leaving this option on with only one '
    txt3 = 'object selected may cause strange bake results.'
    scene.zbBakeSelectedToActive = bpy.props.BoolProperty(
    name = 'Selected To Active',
    default = False,
    description = txt1+txt2+txt3
    )
    txt1 = 'Checking this will cause all selected objects to bake to the same uv map '
    txt2 = 'and image. The map size and type will be generated from the current Zero Brush '
    txt3 = 'settings which can be adjusted in the options menu (adjust these settings before '
    txt4 = 'baking if needed).'
    scene.zbBakeSingle = bpy.props.BoolProperty(
    name = 'Bake Single',
    default = False,
    description = txt1+txt2+txt3+txt4
    )
    scene.zbDisablePopup = bpy.props.BoolProperty(
    name = 'Disable Popup Info',
    default=False,
    description = 'Disable popup information related to Zero Brush tools and baking. '+txtNote
    )
    text1 = 'Paint ZB layers onto complex materials rather than overwrite them with new Zero Brush '
    text2 = 'materials. Can not switch between BR and Cycles for a material painted with this mode. '
    scene.zbAState = bpy.props.BoolProperty(default=False,
    description = text1+text2+txtNote)    
    text1 = 'Pressing this will mirror the weight paint of your object along the '
    text2 = 'X axis (if mesh is properly symmetrical). It will also activate, '
    text3 = '"Multi-Paint" option so you can select the bone (and opposite mirrored '
    text4 = 'bone), so you can see the effects of the mirror painting.'
    text5 = text1+text2+text3+text4
    scene.zbWeightMirror = bpy.props.BoolProperty(
    name = 'X Axis Mirror Editing',
    description = text5,
    default = False,
    update = zbWeightMirror
    )
    wm.zbMakeBonesSelectable = bpy.props.BoolProperty(
    name = 'Make Bones Selectable',
    description = 'Press this if unable to select bones while weight painting',
    default = False,
    update = zbMakeBonesSelectable
    )
    wm.zbLastObjectMode = bpy.props.StringProperty()
    wm.zbSelectParticleMat = bpy.props.StringProperty(
    name = 'Select Material',
    description = 'Select a material to use for this particle layer.',
    update = zbSelectParticleMat
    )
    scene.zbParticleDetailSelect = bpy.props.StringProperty(
    default = 'PARTICLE_EDIT'
    )
    scene.zbAutoGPURender = bpy.props.BoolProperty(default = False,
    name = 'Auto GPU Render',
    update = zbAutoGPURender,
    description = 'Automatically activate the highest possible settings for your graphics\
 card (or cards) to increase Cycles rendering speed. Uncheck to return to CPU render. '+txtNote    
    )
    scene.zbAutoConvertCycles = bpy.props.BoolProperty(default = True,
    description = 'Convert all objects with uv mapped image materials (even if not painted with ZB) to \
 Cycles compatible materials (if does not have already) when using Cycles. '+txtNote
    )
    scene.zbPrecisePaintOption = bpy.props.BoolProperty(default = False,
    description = 'Use W,S,A,D to rotate and arrow keys to pan in texture paint mode.\
 Use Ctrl + arrow keys to precise move stencil. MMB to exit',
    update = zbPrecisePaintOption
    )
    scene.zbAutoConvertLamps = bpy.props.BoolProperty(default = False,
    description = 'Auto convert lamps to work for both Cycles and Blender \
 Render when switching between the two engines')
    scene.zbDistractionFreeMode = bpy.props.BoolProperty(default = True,
    update = zbDistractionFreeMode,
    description="Auto shut off grid and axis when sculpting and painting. "+txtNote)
    wm.zbGradientSwitch = bpy.props.BoolProperty(
    default= False,
    description= 'Switch between gradient and color wheel modes',
    update = zbGradientSwitch
    )
    wm.zbBeforeGradBrush = bpy.props.StringProperty()
    wm.zbLampBufferSize = bpy.props.IntProperty(default=0)
    wm.zbSaveLayerOptions = bpy.props.BoolProperty(default = False)
    scene.zbSaveToHardDrive = bpy.props.BoolProperty(default = False,
    description='Save images dynamically to a folder on your\
 hard drive so you can export or edit them externaly')
    wm.zbSaveImagePath = bpy.props.StringProperty(
    name = "ZB Save Image Path",
    description = "Choose path to save images to disk",
    subtype = 'DIR_PATH',
    update = fu13)
    wm.zbNewSavePath = bpy.props.BoolProperty(
        default = True)
    wm.zbSaveType = bpy.props.EnumProperty(
        update = zbSaveType,
        items=(
            ('.PNG', ".PNG", "",'NONE', 0),
            ('.TIFF', ".TIFF", "",'NONE', 1),
            ('.JPEG', ".JPEG", "",'NONE', 2),
            ('.TGA', ".TGA", "",'NONE', 3),
        ))
    txt1 = 'Use "Lightmap Pack" to create the object uv map instead of '
    txt2 = '"Smart UV Project" (if no seams or existing uv-map found).'
    scene.zbUseLightMap = bpy.props.BoolProperty(default = False,
    description = txt1+txt2
    )
    wm.zbLastBrushBlend = bpy.props.StringProperty(
    name = "Last Brush Blend Mode",
    default = "MIX")
    txt1 = 'The size of the next layer you add (also controls size of new bakes and normal maps). '
    txt2 = 'Changing the width value automatically sets the height value (to save time) to be the same so if you '
    txt3 = 'need different values for width and height, set the height value after changing the width.'
    scene.zbImgSize = bpy.props.FloatProperty(
    name="New Layer Size",
    description = txt1+txt2+txt3,
    default = 2048,
    update = fu29,
    min = 64,
    precision = 0,
    step = 6400)
    scene.zbImgSizeH = bpy.props.FloatProperty(
    name = 'Next new layer height',
    description = txt1+txt2+txt3,
    default = 2048,
    precision = 0,
    min = 64,
    step = 6400)
    wm.zbHidePaintOptions = bpy.props.BoolProperty(
    description = 'Expand Brush Options')
    wm.showBrushLayerOptions = bpy.props.BoolProperty(default=False)
    scene.zbAutoSaveLayers = bpy.props.BoolProperty(
    name = "Auto Save layers", description = "Autosave paint layers when exiting\
 texture paint mode (via ZB's mode selection menu). "+txtNote,
    default = True)
    scene.zbSaveWhenSave = bpy.props.BoolProperty(
    name = 'Autosave (with file)',
    description = 'Ensure that layer images are saved whenever saving the Blend file. '+txtNote,
    default = True
    )        
    wm.zbPaintThrough = bpy.props.BoolProperty(
    name = "Paint Through", description = "Paint or erase all the way through your object",
    update = fu23)
    scene.zbDisableShadows = bpy.props.BoolProperty(
    default = True,
    name = "Disable Shadows",
    description = "Disable shadows from lamps when sculpting or \
 texture painting (increases performance).", update = fu23)
    scene.zbFastMode = bpy.props.BoolProperty(
    name = "Fast Mode Toggle", description = "Speed up performance in the 3D Viewport by lowering detail accross the scene",
    update = fu9)
    wm.zbViewMaskMode = bpy.props.BoolProperty(
    name = "View Mask Mode", description = "view your mask brush strokes",
    update = fu6)
    wm.zbUseBrushColor = bpy.props.BoolProperty(
    name = "Use Brush Color", description = "Use your brush's current color\
 as the base color for your next new layer")
    scene.zbLoadImgSculpt = bpy.props.BoolProperty(
    name = "Texture And Sculpt Brush", description = "Load brushes for sculpt\
 and texture paint modes instead of just the mode you're using.")
    scene.zbLoadBrushType = bpy.props.EnumProperty(
        items=(
            ('default', "Load As Default", "When you go to\
 load a brush it will load as a default brush",'RADIOBUT_OFF', 0),
            ('decal', "Load As Decal", "Decal brushes allow you to\
 drag the image your brush is using any where on your object",'RADIOBUT_OFF', 1),
            ('stencil', "Load As Stencil", "This setting will cause brushes\
 to load as a stencil which you can then paint on to your object",'RADIOBUT_OFF', 2),
            ('hard', "Load As Hard", "Hard brushes are ideal for covering\
 a lot of area quickly",'RADIOBUT_OFF', 3)
            )
        )
    scene.zbGoCycles = bpy.props.BoolProperty(
    name = "Change To Cycles",
    description = "Switch between Cycles and Blender Internal Render Engine",
    update = fu26)
    scene.zbQuickLights = bpy.props.BoolProperty(
    name = "ZB Quick Lights",
    description = 'Generate an advanced light rig while in Cycles',
    update = fu24)
    scene.zbLastWorld = bpy.props.StringProperty(
    name = "ZB Last World", description = "Remember the last world child",)
addon_keymaps = []
def fu33(kmi_props, attr, value):
    try:
        setattr(kmi_props, attr, value)
    except:
        pass
def register():
    bpy.utils.register_module(__name__)
    try:
        wm = bpy.context.window_manager
        km = wm.keyconfigs.addon.keymaps.new(name='3D View', space_type='VIEW_3D')
        kmi = km.keymap_items.new("screen.sf_zb_init_listener", 'MOUSEMOVE', 'ANY')
        kmi = km.keymap_items.new("wm.call_menu", 'Q','PRESS')
        fu33(kmi.properties, 'name', 'view3D.zb_layer_options_menu')
        km = wm.keyconfigs.addon.keymaps.new(name='Sculpt', space_type='EMPTY')
        kmi = km.keymap_items.new("wm.call_menu", 'SPACE','PRESS')
        fu33(kmi.properties, 'name', 'menu.zb_brush_menu')
        kmi = km.keymap_items.new("object.zb_sub_multires", 'W','PRESS')
        kmi = km.keymap_items.new('sculpt.zb_stroke_smooth', 'LEFTMOUSE', 'PRESS', ctrl=True)
        kmi = km.keymap_items.new('sculpt.zb_stroke_inverse', 'LEFTMOUSE', 'PRESS', shift=True)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS')
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.sculpt.brush.size')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.size')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_size')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.sculpt.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.sculpt.brush.cursor_color_add')
        fu33(kmi.properties, 'image_id', 'tool_settings.sculpt.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', shift=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.sculpt.brush.strength')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.strength')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_strength')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.sculpt.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.sculpt.brush.cursor_color_add')
        fu33(kmi.properties, 'image_id', 'tool_settings.sculpt.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', ctrl=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.sculpt.brush.texture_slot.angle')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.sculpt.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.sculpt.brush.cursor_color_add')
        fu33(kmi.properties, 'image_id', 'tool_settings.sculpt.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        km = wm.keyconfigs.addon.keymaps.new(name='Image Paint', space_type='EMPTY', modal=False)
        kmi = km.keymap_items.new("wm.call_menu", 'SPACE','PRESS')
        fu33(kmi.properties, 'name', 'menu.zb_brush_menu')
        kmi = km.keymap_items.new("paint.zb_erase_paint", 'LEFTMOUSE','PRESS', shift=True)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS')
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.image_paint.brush.size')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.size')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_size')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.image_paint.brush.mask_texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.image_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.image_paint.brush.color')
        fu33(kmi.properties, 'zoom_path', 'space_data.zoom')
        fu33(kmi.properties, 'image_id', 'tool_settings.image_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', shift=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.image_paint.brush.strength')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.strength')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_strength')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.image_paint.brush.mask_texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.image_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.image_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.image_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', ctrl=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.image_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.image_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.image_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.image_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.image_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', ctrl=True, alt=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.image_paint.brush.mask_texture_slot.angle')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.image_paint.brush.mask_texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.image_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.image_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.image_paint.brush')
        fu33(kmi.properties, 'secondary_tex', True)
        kmi = km.keymap_items.new('paint.sample_color', 'I', 'PRESS')
        kmi = km.keymap_items.new('paint.brush_colors_flip', 'C', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Vertex Paint', space_type='EMPTY')
        kmi = km.keymap_items.new("wm.call_menu", 'SPACE','PRESS')
        fu33(kmi.properties, 'name', 'menu.zb_brush_menu')
        kmi = km.keymap_items.new("paint.zb_erase_paint", 'LEFTMOUSE','PRESS', shift=True)
        kmi = km.keymap_items.new("paint.zb_erase_paint", 'LEFTMOUSE','PRESS', ctrl=True)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS')
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.vertex_paint.brush.size')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.size')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_size')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.vertex_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.vertex_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.vertex_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.vertex_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', shift=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.vertex_paint.brush.strength')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.strength')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_strength')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.vertex_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.vertex_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.vertex_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.vertex_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', ctrl=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.vertex_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.vertex_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.vertex_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'fill_color_path', 'tool_settings.vertex_paint.brush.color')
        fu33(kmi.properties, 'image_id', 'tool_settings.vertex_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('paint.sample_color', 'I', 'PRESS')
        km = wm.keyconfigs.addon.keymaps.new(name='Weight Paint', space_type='EMPTY')
        kmi = km.keymap_items.new("paint.zb_select_weight_mirror", 'SELECTMOUSE', 'PRESS', ctrl = True)
        kmi.active = False
        kmi = km.keymap_items.new("wm.call_menu", 'SPACE','PRESS')
        fu33(kmi.properties, 'name', 'menu.zb_brush_menu')
        kmi = km.keymap_items.new("paint.zb_erase_paint", 'LEFTMOUSE','PRESS', shift=True)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS')
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.weight_paint.brush.size')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.size')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_size')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.weight_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.weight_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'image_id', 'tool_settings.weight_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        kmi = km.keymap_items.new('wm.radial_control', 'X', 'PRESS', shift=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.weight_paint.brush.strength')
        fu33(kmi.properties, 'data_path_secondary', 'tool_settings.unified_paint_settings.strength')
        fu33(kmi.properties, 'use_secondary', 'tool_settings.unified_paint_settings.use_unified_strength')
        fu33(kmi.properties, 'rotation_path', 'tool_settings.weight_paint.brush.texture_slot.angle')
        fu33(kmi.properties, 'color_path', 'tool_settings.weight_paint.brush.cursor_color_add')
        fu33(kmi.properties, 'image_id', 'tool_settings.weight_paint.brush')
        fu33(kmi.properties, 'secondary_tex', False)
        km = wm.keyconfigs.addon.keymaps.new(name='Paint Curve', space_type='EMPTY')
        kmi = km.keymap_items.new("paintcurve.add_point_slide", 'LEFTMOUSE','PRESS', ctrl=True)
        km = wm.keyconfigs.addon.keymaps.new(name='Particle', space_type='EMPTY')
        kmi = km.keymap_items.new("wm.call_menu", 'SPACE','PRESS')
        fu33(kmi.properties, 'name', 'menu.zb_brush_menu')
        kmi = km.keymap_items.new("wm.radial_control", 'X','PRESS')
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.particle_edit.brush.size')
        kmi = km.keymap_items.new("wm.radial_control", 'X','PRESS', shift=True)
        fu33(kmi.properties, 'data_path_primary', 'tool_settings.particle_edit.brush.strength')
        km = wm.keyconfigs.addon.keymaps.new(name='3D View', space_type='VIEW_3D')
        kmi = km.keymap_items.new("object.zb_render_prev", 'Z','PRESS', shift = True)
        addon_keymaps.append(km)
    except:
        pass
def unregister():
    bpy.utils.unregister_module(__name__)
    wm = bpy.context.window_manager
    for km in addon_keymaps:
        wm.keyconfigs.addon.keymaps.remove(km)
    del addon_keymaps[:]
if __name__ == "__main__":
    register()
